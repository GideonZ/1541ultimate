;-------------------------------------------------
; Ultimate Player V1.1 - Sidplayer for the 1541 Ultimate
;
; Programmed by Wilfred Bos - April 2009
;
; Copyright (c) 2009 - 2011 Wilfred Bos / Gideon Zweijtzer
;
; Info:
;  Call the player by activating the cartridge and performing a reset. Pass tune
;  selection in the SID header at offset $10 (default song)
;  The player needs a SID header which is located somewhere in memory. The SID
;  header should be located at address $XX00. The location of the header should
;  be passed at address $0164/$0165 after a DMA load of the song + header data.
;  The version ($04), data offset ($06), load address ($08), init address ($0A)
;  play address ($0C), songs ($0e) and startSong ($10) in the SID header should
;  be set in little endian format. The original SID header is in big endian
;  format.
;  The SID header should include the load address at $7c (if present). Therefore
;  just copy the original SID header till $7e in front of the player.
;  Set the load end address of the SID tune after the SID header at $7e in little
;  endian format.
;
;  The following zero page addresses are used and will be removed afterwards:
;
;  $F7 and $F8 are used temporarely
;  $FA = low byte SID header
;  $FB = high byte SID header and player address
;  $FC = song to play
;  $FD = use CIA timer boolean (0 = No CIA, other value means that CIA should be used)
;  $FE and $FF are used temporarely
;-------------------------------------------------

              *= $8000            ;base address of cartridge

              .byte <start        ;cold start vector
              .byte >start
              .byte <startNMI     ;nmi vector
              .byte >startNMI
              .byte 'C' + $80, 'B' + $80, 'M' + $80, '80'   ;CBM80

              .text $00, 'Ultimate SID Player Cartridge V1.1. Copyright (c) 2009-2011 Wilfred Bos / Gideon Zweijtzer', $00

startNMI      pla                 ;just ignore pressing restore key
              tay
              pla
              tax
              pla
              rti
              
start         sei
              lda #$7f
              sta $dd0d
              lda $dd0d
      
              ldx #$00
              stx $d011
              stx $d020
              stx $d021
              stx $d418

              jsr $ff84           ;init I/O devices / CIA timers

              ;jsr $ff87          ;init RAM, tape buffer, screen (replaced by the following)

              ldx #$00
              lda #$00
-             sta $0200,x
              inx
              bne -
              lda #$A0
              sta $0284
              lda #$08
              sta $0282
              lda #$04
              sta $0288

              jsr $ff8a           ;restore default IO vectors

              ; set test bit of each voice to guarantee synced voices!
              lda #$08
              sta $d404
              sta $d404 + 7
              sta $d404 + 14
              lda #$00
              sta $d404
              sta $d404 + 7
              sta $d404 + 14
              
              lda $02
              cmp #$AA
              beq sid_mode
              cmp #$AB
              beq dma_mode
              jmp reset
              
dma_mode
							;load PRG file
              lda #$00
              sta $02
              
              jsr $ff81     			;(init screen and VIC-Chip the normal way)
              jmp continue_initializing

sid_mode
	            ;jsr $ff81 (init screen and VIC-Chip) is replaced by the following block
              ;to avoid screen color change
              lda #$03
              sta $9a
              lda #$00
              sta $99
              ldx #$2f
-             lda $ecb8,x
              sta $cfff,x
              cpx #$23    				;don't set $d020 and $d021
              bne +
              dex
              dex              
+             cpx #$13    				;don't set d011
              bne +
              dex              
+             dex
              bne -

continue_initializing
              jsr $e51b
              jsr $ff5e
              jsr $e453           ;copy BASIC vectors to RAM

              lda $0300
              sta $0334
              lda $0301
              sta $0335
              lda #<basicStarted
              sta $0300
              lda #>basicStarted
              sta $0301
              lda $a001
              sta $0101
              lda $a000
              clc
              adc #$03            ;skip JSR $E453 to avoid overwriting vector at $0300
              sta $0100
              bcc +
              inc $0101
              cli
+             jmp ($0100)
         
basicStarted
              lda $0334
              sta $0300
              lda $0335
              sta $0301

              sei
              lda #<basicStartedIRQ
              sta $0314
              lda #>basicStartedIRQ
              sta $0315
              
              jmp ($0300)

basicStartedIRQ              
              lda #$31            ;restore IRQ vector
              sta $0314
              lda #$ea
              sta $0315

              lda $dc0d           ;acknowledge IRQ

              lda $02
              cmp #$AA
              beq load_sid

              ldx #$00
-             lda initMem,x
              sta $0100,x
              inx
              cpx #initMemEnd - initMem
              bne -
              jmp $0100           ;clear memory and execute DMA load, and do run

load_sid      
              ldx #$ff            ;init stack pointer
              txs
              lda #$fc            ;push reset address on stack
              pha
              lda #$e2 - 1
              pha

              lda #$ea
              sta $0328           ;disable runstop/restore

              ldx #$00
-             lda initMem,x
              sta $0100,x
              inx
              cpx #initMemEnd - initMem
              bne -
              jsr $0100           ;clear memory and execute DMA load

              ;important: load $0165 value after DMA load
              lda $0165           ;get high address of SID header              
              sta $fb             ;store SID header address high byte and expect that $fa is $00
              lda #$00
              sta $fa

              ldx #$00
-             lda readHeader,x
              sta $0180,x
              inx
              cpx #readHeaderEnd - readHeader
              bne -

              ldy #$01            ;detect if header is a real SID header
              jsr $0180           ;read header
              cmp #'S'
              bne reset
              iny
              jsr $0180           ;read header
              cmp #'I'
              bne reset
              iny
              jsr $0180           ;read header
              cmp #'D'
              beq SIDHeaderDetected         

              ;if header is no real header then disable cartridge and perform a reset
reset
              ldx #$00
-             lda resetRoutine,x
              sta $0100,x
              inx
              cpx #resetRoutineEnd - resetRoutine
              bne -
              jmp $0100

SIDHeaderDetected
              ldy #$10            ;default song offset
              jsr $0180           ;read header
              sta $fc             ;set song to play

              ldx #$00
              stx $d1             ;set screen line address to header address to avoid blinking cursor on screen for some tunes
              sta $d2

;--- load address ---------
              
;Get real load address
              ldy #$08            ;get load address
              jsr $0180           ;read header
              bne +
              iny
              jsr $0180           ;read header
              bne +               ;is load address zero?
              
              ;load address is zero then overwrite with other load address
              ldy #$06            ;get header length
              jsr $0180           ;read header
              tax
              tay
              jsr $0180           ;read header (get load address low)
              ldy #$08            ;set load address low
              sta ($fa),y
              inx
              txa
              tay
              jsr $0180           ;read header (get load address high)
              ldy #$09            ;set load address high
              sta ($fa),y
+

;--- set screen ---------
              
;map screen and optional charset
              lda $dd00
              and #%11111100
              sta $fd

              ldy #$00
              jsr $0180           ;read header
              cmp #"R"            ;check if RSID file
              bne +
              ldy #$77
              jsr $0180           ;read header
              and #$02            ;is BASIC tune?
              beq +
              lda #$a0            ;always map BASIC screen to $A000 to avoid BASIC programs to do screen writes
              jmp mapScreen
+

              ldy #$78            ;get free page base
              jsr $0180           ;read header
              bne checkFreePageSize

;Free page base is zero, so check if $0400 can be used
              lda $fb
              and #$f8            ;are we located below $0800?
              beq +
              and #$f0
              bne screenAfterPlayer
             
              ldy #$09            ;get load address high
              jsr $0180           ;read header
              and #$f0            ;is load address lower than $1000?
              bne mapTo0400
+
;load address is lower than $1000
              ldy #$09
              jsr $0180
              cmp #$07
              bpl +
              bne screenAfterPlayer
              cmp #$e8
              bmi screenAfterPlayer
              and #$80
              beq screenAfterPlayer

+             lda $fa
              sta $fe
              lda $fb
              clc
              adc #$02
              sta $ff

              ;move SID header
              ldy #$00
-             lda ($fa),y
              sta ($fe),y
              iny
              bne -
              lda $fb
              inc $fb
              inc $fb
              jmp defaultScreen

screenAfterPlayer
              ldy #$7f            ;get load end address high
              jsr $0180           ;read header
              clc
              adc #$01 + $03
              jmp mapScreen
              
mapTo0400     lda #$04
              jmp defaultScreen
              
checkFreePageSize              
              ldy #$79            ;get free page size
              jsr $0180           ;read header
              and #$f8
              bne checkScreenSize 
              
              ldy #$79            ;get free page size
              jsr $0180           ;read header
              and #$fc
              beq +
;size is greater or equal than 4

              lda $fb
              clc
              adc #$03            ;to avoid address to be truncated (like $39, $3A and $3B becomes $38), #$03 will round free pages $39, $3A and $3B to $3c
              and #%11111100      ;align to $x000, $x400, $x800 or $xC00 pages
              clc
              adc #$02
              sta $ff

              lda $fa
              sta $fe

              ;move SID header
              ldy #$00
-             lda ($fa),y
              sta ($fe),y
              iny
              bne -
              lda $ff
              sta $fb
              sec
              sbc #$02             
              jmp mapScreen

+
              ;size is lower than $04 so we can't have a screen, therefore
              ;  locate screen after load end address + $0700 and #%11111100
              ldy #$7f
              jsr $0180           ;read header
              and #$f8            ;is load end address $F800 or higher?
              cmp #$f8        
              beq noScreenPossible              

              jsr $0180           ;read header
              clc
              adc #$07
              jmp mapScreen
                  
noScreenPossible                            
              ldx #$00            ;make character color black
              txa
-             sta $d800,x
              sta $d900,x
              sta $da00,x
              sta $db00,x
              inx
              bne -
              jmp ScreenDone
              
checkScreenSize
;check if player size ($0800) + screen size ($0400) + optional ($1000) can fit in memory              
              
              ldy #$78            ;get free page base
              jsr $0180           ;read header
              clc
              adc #$0b            ;to avoid address to be truncated (like $39, $3A and $3B becomes $38), add #$08 to skip player location and #$03 will round free pages $39, $3A and $3B to $3c
mapScreen     and #%11111100      ;align to $x000, $x400, $x800 or $xC00 pages
              pha
              
;check if default charset location can be used
              and #%11000000
              beq defaultCharSet  
              cmp #$80           
              bne mapCharSet      
              
defaultCharSet              
              lda #$10            ;means default charset location should be used (#$10 shr 2)
              sta $ff
              jmp checkRam
              
mapCharSet    pla
              pha
              and #$f0
              cmp #$d0      
              bne +
              pla
              clc
              adc #$10
              pha
+             pla
              pha
              and #$04
              bne screenLocationOk
              pla
              sta $ff             ;charset location high
              clc
              adc #$04
              pha
              jmp copyChars
screenLocationOk          
              pla
              pha
              clc
              adc #$04
              sta $ff             ;charset location high
              
copyChars     lda #$d0
              sta $f8
              
              ;$ff is charset destination address
              ldy #$00
              sty $fe
              sty $f7
              
              ldx #$00
-             lda CharROMCopy,x
              sta $0100,x
              inx
              cpx #CharROMCopyEnd - CharROMCopy
              bne -
              
copyChrLoop   jsr $0100
              iny
              bne copyChrLoop
              inc $ff
              inc $f8
              lda $f8
              cmp #$d4
              bne copyChrLoop
              
checkRam    
              pla
              pha
              and #$f0
              cmp #$10
              beq ramAreaNOK
              cmp #$d0
              beq ramAreaNOK
              cmp #$90
              bne ramAreaOK
ramAreaNOK              
              pla
              and #$f0
              clc
              adc #$13
              and #%11111100  		;align to $x000, $x400, $x800 or $xC00 pages
              pha
ramAreaOK     pla
              pha      
              rol
              rol
              tax
              rol
              eor #$ff
              and #$03
              ora $fd
              sta $dd00           ;set correct bank
                 
              lda $d018
              and #%00000001
              
              sta $fe
              
              lda $ff
              ror
              ror
              and #%00001110      ;set charset address
              ora $fe 
              sta $fe
              
              txa
              and #$f0
              ora $fe
              sta $d018

              pla

defaultScreen

; fill screen and colors
              pha
              sta $f8             ;$f7/$f8 is now screen address
              lda #$00
              sta $f7
              
; fill colors 
              ldx #$00             
-             lda #$0f            ;light grey
              sta $d800,x
              sta $d900,x
              sta $db00,x
              lda #$00            ;black
              sta $da00,x
              dex
              bne -
              ldx #40
              lda #$01            ;white
-             sta $d7ff,x
              dex 
              bne -
              
              ldx #8
              lda #$07            ;yellow
-             sta $d7ff + 40 * 3,x
              sta $d7ff + 40 * 4,x
              sta $d7ff + 40 * 5,x
              sta $d7ff + 40 * 7,x
              sta $d7ff + 40 * 8,x
              sta $d7ff + 40 * 10,x
              dex 
              bne -  
              
              lda #$01
              sta $dbe0
              sta $dbe1
              sta $dbe2

; fill screen              
              ldx #$00
-             lda ScreenWrite,x
              sta $0100,x
              inx
              cpx #(ScreenWriteEnd - ScreenWrite) + 1
              bne -
              
              lda #<screenData1
              sta $fe
              lda #>screenData1
              sta $ff
       
              jsr writeScreenData
              
              ;skip 256 bytes to make it possible to have the sid header on the screen (invisible)
              
              inc $f8
              lda #$00
              sta $f7

              lda #<screenData2
              sta $fe
              lda #>screenData2
              sta $ff
       
              jsr writeScreenData
              
              pla
              pha
              sta $ff             ;$fe/$ff is now screen address
              lda #$00
              sta $fe
        
              lda $fa             ;backup sid header address
              sta $f7

              lda $fb
              sta $f8

              lda #$16            ;offset title in SID header
              sta $fa
              
              lda #10 + 40 * 3
              sta $fe
              ldx #30             ;print max 30 chars (ignore last char)
              jsr printData       ;write title data to screen

              lda #$36            ;offset author in SID header
              sta $fa
              
              lda #10 + 40 * 4
              sta $fe
              ldx #30             ;print max 30 chars (ignore last char)
              jsr printData       ;write title data to screen

              lda #$56            ;offset released in SID header
              sta $fa
              
              lda #10 + 40 * 5
              sta $fe
              ldx #30             ;print max 30 chars (ignore last char)
              jsr printData       ;write title data to screen

              lda $f7             ;restore sid header address
              sta $fa

              lda $f8
              sta $fb

;Print Clock info
              ldy #$04            ;check version
              jsr $0180           ;read header
              cmp #$01
              beq printUnknownClock
              
              ldy #$77
              jsr $0180
              lsr
              lsr
              and #$03
              cmp #$00
              beq printUnknownClock
              cmp #$01
              beq printPal
              cmp #$02
              beq printNtsc

              ;print "PAL / NTSC"
              lda #<PALNTSCLbl
              sta $aa
              lda #>PALNTSCLbl
              sta $ab
              jmp printClock

printPal      lda #<PALLbl
              sta $aa
              lda #>PALLbl
              sta $ab
              jmp printClock

printNtsc     lda #<NTSCLbl
              sta $aa
              lda #>NTSCLbl
              sta $ab
              jmp printClock

printUnknownClock
              lda #<UnknownLbl
              sta $aa
              lda #>UnknownLbl
              sta $ab
              
printClock    lda $ff
              clc
              adc #$01
              sta $f8
              lda #9 + 40 * 7 // $ff
              sta $f7

              ldy #$00            
-             lda ($aa),y
              cmp #$00
              beq +
              jsr $0100           ;write to screen
              iny
              bne -
+

;Print model info
              ldy #$04            ;check version
              jsr $0180           ;read header
              cmp #$01
              beq printUnknownModel
              
              ldy #$77
              jsr $0180
              lsr
              lsr
              lsr
              lsr
              and #$03
              cmp #$00
              beq printUnknownModel
              cmp #$01
              beq print6581
              cmp #$02
              beq print8580

              ;print "6581 / 8580"
              lda #<S65818580Lbl
              sta $aa
              lda #>S65818580Lbl
              sta $ab
              jmp printModel

print6581     lda #<S6581Lbl
              sta $aa
              lda #>S6581Lbl
              sta $ab
              jmp printModel

print8580     lda #<S8580Lbl
              sta $aa
              lda #>S8580Lbl
              sta $ab
              jmp printModel

printUnknownModel
              lda #<UnknownLbl
              sta $aa
              lda #>UnknownLbl
              sta $ab
              
printModel    lda $ff
              clc
              adc #$01
              sta $f8
              lda #9 + 40 * 8 // $ff
              sta $f7

              ldy #$00            
-             lda ($aa),y
              cmp #$00
              beq +
              jsr $0100           ;write to screen
              iny
              bne -
+

;print number of songs
              lda #(9 + 40 * 10) // $ff
              sta $fe
              inc $ff

              ldx #'0'              
              lda $fc
              pha

              cmp #$ff              
              bne skipFirstNibble
              ldy #$00
              lda #'2'
              sta ($fe),y
              inc $fe
              lda #'5'
              sta ($fe),y
              inc $fe
              lda #'6'
              sta ($fe),y
              inc $fe
              bne writeCurrentSongDone   
                            
skipFirstNibble
              pla
              jsr printNibble
writeCurrentSongDone              

              inc $fe
              lda #$2f
              ldy #$00
              sta ($fe),y
              inc $fe
              inc $fe
              
              ldy #$0f
              jsr $0180           ;read header
              and #$01
              beq songs255
              ldy #$00
              lda #'2'
              sta ($fe),y
              iny
              lda #'5'
              sta ($fe),y
              iny
              lda #'6'
              sta ($fe),y
              bne ScreenDone         
             
songs255      ldy #$0e
              jsr $0180           ;read header
              tax
              dex
              txa
              jsr printNibble         
             
ScreenDone    lda #$1b
              sta $d011

              lda #$c8
              sta $d016
              
;--- init SID chip ---------
              
              ldx #$19
-             lda #$00
              sta $d3ff,x
              dex
              bne -
              
              lda #$0f
              sta $d418

;set end address of file (not required anymore since 1541 Ultimate loader is setting the zero page addresses now)
              ldy #$7e
              jsr $0180           ;read header
              sta $2d
              sta $2f
              sta $31
              sta $ae
              iny
              jsr $0180           ;read header
              sta $2e
              sta $30
              sta $32
              sta $af

;Check if RSID file
              ldy #$00
              jsr $0180           ;read header
              cmp #"R"            ;check if RSID file
              beq rsidFile
              jmp psidFile

;===============================================================================
; RSID file             
;===============================================================================
              
rsidFile      ldy #$80
              ldx #$00
-             lda rsidroutine,x
              sta ($fa),y
              iny
              inx
              cpx #rsidroutineEnd - rsidroutine
              bne -

              lda #<rsidplay - rsidroutine + $80
              sta $fe
              lda #>rsidplay - rsidroutine
              clc
              adc $fb
              sta $ff

              ldy #$0a            ;check if init address is zero
              jsr $0180           ;read header
              bne runRSID
              iny
              jsr $0180           ;read header
              bne runRSID
              
              ;init address is zero
              ldy #$77
              jsr $0180           ;read header
              and #$02            ;is BASIC tune?
              beq noBasic
              ;It's a BASIC file

              lda $ff
              sta $0301           ;vector that is called when end of BASIC code is reached or when BASIC error

              lda $fe
              clc
              adc #$03
              sta $0300
              bcc noPageCrossed
              inc $0301
noPageCrossed
              lda $0803
              sta $39
              lda $0804
              sta $3a
              
              lda #$ae
              ldy #$01
              sta ($fe),y
              lda #$a7
              iny
              sta ($fe),y
              jmp setSongAndRun             
              
noBasic       ldy #$09            ;get load address high
              jmp jmpToAddress              
    
runRSID       ldy #$0b            ;get init address high
jmpToAddress         
              jsr $0180           ;read header
              pha
              dey
              jsr $0180           ;read header
              ldy #$01
              sta ($fe),y
              iny
              pla
              sta ($fe),y

setSongAndRun    
              ldx #$00
-             lda runRoutine,x
              sta $0100,x
              inx
              cpx #runRoutineEnd - runRoutine
              bne -

              lda $fc
              sta $030c           ;set song to play in accumulator, x-register and y-register of BASIC
              sta $030d
              sta $030e  
              
              ldx #$00            ;clear temp variables; $fa is always zero so no need to clear
              stx $fc
              stx $fe
              stx $ff
              
              stx $aa
              stx $ab
              
              stx $f7
              stx $f8

              ldx #$80
              stx $fa
                     
              jmp $0100
             
;===============================================================================
; PSID file             
;===============================================================================

psidfile      ldy #$0a            ;get init address
              jsr $0180           ;read header
              bne +
              iny
              jsr $0180           ;read header
              bne +               ;is init address zero?
              
              ;init address is zero then overwrite with load address
              ldy #$08            ;get load address low
              jsr $0180           ;read header
              ldy #$0a            ;set init address low
              sta ($fa),y
              dey                 ;get load address high
              jsr $0180           ;read header
              ldy #$0b            ;set init address high
              sta ($fa),y
+

              ;check if init is same as play, then ignore play address
              ldy #$0c            ;get play address low
              jsr $0180           ;read header
              sta $78
              ldy #$0a            ;compare with init low
              jsr $0180           ;read header
              cmp $78
              bne +
              ldy #$0d            ;get play address high
              jsr $0180           ;read header
              sta $78
              ldy #$0b            ;compare with init high
              jsr $0180           ;read header
              cmp $78
              bne +

              ;clear play address    
              ldy #$0c
              lda #$00
              sta ($fa),y
              iny
              sta ($fa),y
+   

;copy play routine
              ldx #$00
              ldy #$80
-             lda playRoutine,x
              sta ($fa),y
              iny
              inx
              cpx #playRoutineEnd - playRoutine
              bne -

              lda #play - playRoutine + $80
              sta $fe
              lda $fb
              sta $ff

              ldy #$0c            ;copy play address
              jsr $0180           ;read header
              ldy #$05           
              sta ($fe),y
              ldy #$0d
              jsr $0180           ;read header
              ldy #$06           
              sta ($fe),y

              jsr getBankPlay    	;call getBank, input is play high address in accumulator
              ldy #$01
              sta ($fe),y
              
              lda #init - playRoutine + $80
              sta $fe
              lda $fb
              sta $ff

              ldy #$0a            ;copy init address
              jsr $0180           ;read header
              ldy #$07           
              sta ($fe),y
              ldy #$0b
              jsr $0180           ;read header
              ldy #$08           
              sta ($fe),y

              jsr getBankInit     ;call getBank, input is init high address in accumulator
              ldy #$01
              sta ($fe),y              

              ldy #$0c
              jsr $0180           ;read header
              bne setBankAfterInit
              iny
              jsr $0180           ;read header
              bne setBankAfterInit
              
              lda #$ea            ;nop sta $01 after init
              pha
              pha
              bne afterInitSet

setBankAfterInit
              lda #$01        
              pha
              lda #$85            ;STA $01
              pha
              
afterInitSet              
              ldy #$0b
              pla
              sta ($fe),y
              iny
              pla
              sta ($fe),y

;check playsid specific flag
              lda $fc             ;get song to play
              bne readSpeedBits   ;if song is first song (#0) than read speed bit immediately
              ldy #$15
              jsr $0180           ;read header
              jmp readSpeedBit
              
readSpeedBits              
              tax

              ldy #$04            ;check version
              jsr $0180           ;read header
              cmp #$01
              beq oldVersion
              ldy #$77
              jsr $0180           ;read header
              and #$02            ;is PlaySID specific?
              beq oldVersion

              txa                 ;get song to play     
              and #$e0            ;check if greater than 31
              bne newVersion
loop1
              ldy #$12            ;start at byte 4 of speed flags
              clc
              jsr $0180           ;read header (speed flag byte4)
              ror              
              sta ($fa),y                                                                     
              iny
              jsr $0180           ;read header (speed flag byte3)
              ror              
              sta ($fa),y                                                                     
              iny
              jsr $0180           ;read header (speed flag byte2)
              ror              
              sta ($fa),y                                                                     
              iny
              jsr $0180           ;read header (speed flag byte1)
              ror              
              sta ($fa),y                                                                     
              dex
              bne loop1              
readSpeedBit              
              and #$01
              sta $fd
              jmp speedFlagsRead        
              
newVersion    ldy #$12            ;start at byte 4 of speed flags
              jsr $0180           ;read header (check byte 4 bit 7)
              and #$80
              sta $fd
              jmp speedFlagsRead        

oldVersion    txa                 ;get song to play
              and #$e0            ;check if less than 32
              beq loop1           ;yes? then go to loop1
              txa
              sec
              sbc #$20
              tax
              jmp oldVersion            
speedFlagsRead
              
              ;check if play address should be ignored
              ldy #$0c
              jsr $0180           ;read header
              bne installPlayer
              iny
              jsr $0180           ;read header
              bne installPlayer
              
              lda $fd
              bne initCIA         ;jump when CIA is used
              
;disable CIA when player address is zero and VBI is used              
initVIC
              lda #$7f
              sta $dc0d
              lda #$00
              sta $dc0e
              lda #$01
              sta $d01a
              lda $dc0d
              jmp processInit
initCIA              
              lda #$81
              sta $dc0d
              lda #$01
              sta $dc0e
              jmp processInit
              
installPlayer 
              lda #speedFix - playRoutine + $80
              sta $fe

              lda $fd
              beq FixedSpeed
              ldy #$02            ;remove sta $dc04 and sta $dc05
              lda #$ea
              sta ($fe),y    
              iny
              sta ($fe),y    
              iny
              sta ($fe),y    
              ldy #$07
              sta ($fe),y    
              iny
              sta ($fe),y    
              iny
              sta ($fe),y    
FixedSpeed              
              ldy #$04            ;check version
              jsr $0180           ;read header
              cmp #$01
              beq defaultSpeed    ;if old version then play at default speed

              ldy #$77
              jsr $0180           ;read header
              ror
              ror
              and #$03            ;filter PAL/NTSC flag, default is PAL
              beq defaultPAL
              and #$01
              bne defaultPAL

defaultNTSCHz lda $02a6
              bne PAL60Hz
             
NTSC60Hz      lda #$c6            ;set NTSC speed (263 * 65 - 1)
              sta $dc04
              ldy #$01
              sta ($fe),y
              lda #$42
              sta $dc05              
              ldy #$06
              sta ($fe),y
              bne playCIA 
              
defaultPAL    lda $fd
              beq defaultPALHz
              
              lda $02a6           ;if CIA Speed flag is set, then always default timer to 60Hz PAL / NTSC
              beq NTSC60Hz

PAL60Hz       lda #$fb            ;set 60Hz based on PAL (312 * 63 * 50 / 60 - 1)
              sta $dc04
              ldy #$01
              sta ($fe),y
              lda #$3f
              sta $dc05              
              ldy #$06
              sta ($fe),y
              bne playCIA              

defaultSpeed  lda $02a6
              beq NTSC60Hz
              bne PAL50Hz

defaultPALHz  lda $02a6
              beq NTSC50Hz
              
PAL50Hz       lda #$c7            ;set PAL speed (312 * 63 - 1)
              sta $dc04
              ldy #$01
              sta ($fe),y
              lda #$4c
              sta $dc05              
              ldy #$06
              sta ($fe),y
              bne playCIA
              
NTSC50Hz      lda #$21            ;set PAL speed (263 * 65 * 60 / 50 - 1)
              sta $dc04
              ldy #$01
              sta ($fe),y
              lda #$50
              sta $dc05              
              ldy #$06
              sta ($fe),y
              bne playCIA 

playCIA       ldx #irqcia - playRoutine + $80
              lda $fb
              stx $0314
              sta $0315
              stx $fffe
              sta $ffff
              
              lda #$81            ;enable CIA A, Timer A
              sta $dc0d
              
              lda #$01            ;start Timer A, continuous
              sta $dc0e
            
processInit   lda $fc             ;get song to play
              pha

              lda #irqbrk - playRoutine + $80
              sta $0316
              lda $fb              
              sta $0317
              
              ldx #$f9
              lda #$00
-             sta $01,x
              dex
              bne -               ;stop when X is zero
              sta $fc
              sta $fd
              sta $fe
              sta $ff
              sta $78

              lda #$80
              sta $fa

              ldx #$00
-             lda runRoutine,x
              sta $0100,x
              inx
              cpx #runRoutineEnd - runRoutine
              bne -

              pla
              jmp $0100           ;call init routine

playRoutine   ldx #$00
              stx $fa
              stx $fb

init          ldx #$00
              stx $01
              tax
              tay
              jsr $0000           ;call init routine of player
           
              ;if play address is null then STA $01 will be NOPPED out
              lda #$37
              sta $01
              cli
              clc
              bcc *

irqbrk        tsx                 ;interpreter BRK as RTS with AC, XR, YR and processor status register restored
              lda $0104,x
              pha
              plp                 ;restore processor status
              lda $0101,x         ;move YR, XR and AC stack position
              sta $0104,x
              lda $0102,x
              sta $0105,x
              lda $0103,x
              sta $0106,x
              inx
              inx
              inx
              txs
              
              pla                 ;restor YR, XR and AC
              tay
              pla
              tax
              pla
              rts

irqcia        lda $01
              pha
play          lda #$00
              sta $01
              jsr $0000
              pla
              sta $01

speedFix      lda #$00
              sta $dc04
              lda #$00
              sta $dc05              
             
              lda $dc0d
              pla
              tay
              pla
              tax
              pla
              rti
              
playRoutineEnd

;input is high address for which the correct bank should be calculated
getBankInit   ldy #$7f  ;get load end address high
              jmp getBank
getBankPlay   ldy #$0d  ;get play address
              jmp getBank              

getBank       and #$f0
              cmp #$d0
              bne isBankKernal
              lda #$34
              rts
isBankKernal  cmp #$e0
              beq bankKernal
              cmp #$f0
              bne isBankBasic
bankKernal    lda #$35
              rts
isBankBasic   jsr $0180           ;read header
              and #$f0
              bpl bankDefault
              cmp #$80
              beq bankDefault
              cmp #$90
              beq bankDefault
              lda #$36
              rts
bankDefault   lda #$37
              rts

;------ X is length
printData     lda #<ASCII
              sta $a9
              lda #>ASCII
              sta $aa
              lda #<PETSCII
              sta $a7
              lda #>PETSCII
              sta $a8

              ldy #$00
fillData      jsr $0180           ;read header
              beq stopPrintData
              
              ;ascii special character to petscii conversion
              sta $a6
              tya
              pha                 ;save index

              ldy #$00
charConvLoop  lda ($a9),y
              beq conversionEnd
              cmp $a6
              bne checkNextChar
              
              lda ($a7),y
              sta $a6
              bne conversionEnd
              
checkNextChar iny
              bne charConvLoop
              
conversionEnd pla
              tay
              lda $a6
              
              pha
              and #$40
              beq noConversion
              pla
              and #$9f
              pha
noConversion  pla
              and #$7f            ;only first 128 chars allowed, so map last 128 to first 128 chars
              sta ($fe),y
              iny
              dex
              bne fillData
stopPrintData rts

printNibble   tax
              inx
countOne              
              sed
              ldy #$00
              lda #$00
convertToDec  clc
              adc #$01
              bcc noIncHundred
              iny
noIncHundred              
              dex
              bne convertToDec 
stopDecConversion
              cld
              
              ldx #$00
              cpy #$00
              beq skipFirstNibble2
              pha
              tya
              clc
              adc #$30
              ldy #$00
              sta ($fe),y         ;print hundred
              inx
              inc $fe
              pla
skipFirstNibble2
              
              pha
              lsr
              lsr
              lsr
              lsr
              cpx #$00
              bne forcePrint1
              cmp #$00
              beq skipSecondNibble

forcePrint1   and #$0f
              clc
              adc #$30
              sta ($fe),y
              inc $fe

skipSecondNibble
              pla
              and #$0f
              clc
              adc #$30
              sta ($fe),y
              inc $fe
              rts

CharROMCopy   lda $01
              pha
              lda #$33
              sta $01
              lda ($f7),y
              pha
              lda #$34
              sta $01
              pla
              sta ($fe),y
              pla
              sta $01
              rts
CharROMCopyEnd

ScreenWrite   pha
              lda $01
              sta $0100 + ScreenWriteEnd - ScreenWrite
              lda #$34
              sta $01
              pla
              sta ($f7),y
              pha
              lda $0100 + ScreenWriteEnd - ScreenWrite
              sta $01
              pla
              rts
ScreenWriteEnd              

resetRoutine  sta $dfff
              inc $8005
              cli
              jmp ($fffc)
resetRoutineEnd

rsidroutine   ldx #$00
              stx $fa
              stx $fb
              tax
              tay
              cli
              
rsidplay      jsr $0000
              clc
              bcc *
rsidroutineEnd              

initMem       lda $01
              pha
              
              lda #$34
              sta $01
              
              lda #$00
              sta $0162

              ldx #$01            ;receive DMA load
              stx $02     
              
-             bit $0162           ;wait till DMA load is ready
              bpl -
              
              pla
              sta $01

              lda #$00
              sta $02             ;restore value of address $0002 to $00

;              lda #$0d
;              sta $d020
;              ldx #0
;              ldy #0
;-             iny
;              bne -
;              inx
;              bne -

              lda $0162
              cmp #$BC
              beq run_basic
              cmp #$AA
              bne go_basic
              rts
run_basic
; WE GET HERE ON INTERRUPT!
              pla ; 3x from the interrupt
              pla
              pla
              sta $dfff ; turn off cartridge
              cli ; we just let the interrupt occur again
              lda #1   ; disable cursor blink
              sta $CC
              lda #'R'
              sta $0200
              lda #'U'
              sta $0201
              lda #'N'
              sta $0202
              lda #0
              sta $13
              ldx #3
              jsr $AACA
              jmp $A486    

go_basic
; WE GET HERE ON INTERRUPT!
              sta $dfff ; turn off cartridge
              jmp $ea31
              
              
initMemEnd

readHeader    lda $01
              sta $0180 + readHeaderEnd - readHeader
              lda #$34
              sta $01
              lda ($fa),y
              pha
              lda $0180 + readHeaderEnd - readHeader
              sta $01
              pla
              rts
readHeaderEnd

runRoutine    sta $dfff
              jmp ($00fa)
runRoutineEnd
              
writeScreenData       
-             ldy #$00
              lda ($fe),y
              beq endScreenWrite
              cmp #$ff
              bne writeData

              ldy #$02
              lda ($fe),y
              tax
              ldy #$01
              lda ($fe),y
              ldy #$00
-             
              jsr $0100           ;write to screen
              inc $f7
              bne +
              inc $f8
+             dex
              bne -
              lda $fe
              clc
              adc #$03
              sta $fe
              bcc +
              inc $ff
+             bne --
              
writeData     jsr $0100           ;write to screen
              
              inc $f7
              bne +
              inc $f8
+             inc $fe
              bne +
              inc $ff
+             bne --
              
endScreenWrite   
              rts

screenData1   ;header
              .byte $20, $20, $20, $2a, $2a, $2a, $2a, $20
              .byte $31, $35, $34, $31, $20, $15, $0c, $14
              .byte $09, $0d, $01, $14, $05, $20, $13, $09
              .byte $04, $20, $10, $0c, $01, $19, $05, $12
              .byte $20, $2a, $2a, $2a, $2a, $20, $20, $20
              
              ;line
              .byte $ff, 'C', 40

              .byte $ff, $20, 40  ;empty line
          
              ;title label
              .byte $14, $09, $14, $0c, $05, $20, $20, $20
              .byte $3a, $ff, $20, 31
          
              ;author label
              .byte $01, $15, $14, $08, $0f, $12, $20, $20
              .byte $3a, $ff, $20, 31              
          
              ;released label
              .byte $12, $05, $0c, $05, $01, $13, $05, $04
              .byte $3a

              .byte $ff, $20, 40*1 + 31  ;1 empty line

              ;Clock label
              .byte $03, $0c, $0f, $03, $0b, $20, $20, $20
              .byte $3a, $ff, $20, 31

              ;Model label
              .byte $0d, $0f, $04, $05, $0c, $20, $20, $20
              .byte $3a

              .byte $ff, $20, 40*1 + 31  ;1 empty line

              ;playing label
              .byte $10, $0c, $01, $19, $09, $0e, $07, $20
              .byte $3a, $ff, $20, 31 + 40 + 32, $00 ;end

screenData2   .byte $ff, $20, 40*2 - 2   ;2 empty lines

              .byte $02, $19, $20, $17, $09, $0c, $06, $12
              .byte $05, $04, $20, $02, $0f, $13, $20, $01
              .byte $0e, $04, $20, $07, $09, $04, $05, $0f
              .byte $0e, $20, $1a, $2e

              .byte $ff, $20, 40*1 + 6 ;5 empty line
              
              ;line
              .byte $ff, 'C', 40
              
              ;footer
              .byte $10, $12, $05, $13, $13
              .byte $20, $0d, $09, $04, $04, $0c, $05, $20
              .byte $02, $15, $14, $14, $0f, $0e, $20, $06, $0f
              .byte $12, $20, $01, $0e, $0f, $14, $08
              .byte $05, $12, $20, $13, $15, $02, $14, $15, $0e, $05, $21
              .byte $00 ;end

PALLbl        .byte $10, $01, $0c, $00
NTSCLbl       .byte $0e, $14, $13, $03, $00
PALNTSCLbl    .byte $10, $01, $0c, $20, $2f, $20, $0e, $14
              .byte $13, $03, $00
UnknownLbl    .byte $15, $0e, $0b, $0e, $0f, $17, $0e, $00
S6581Lbl      .byte $36, $35, $38, $31, $00
S8580Lbl      .byte $38, $35, $38, $30, $00
S65818580Lbl  .byte $36, $35, $38, $31, $20, $2f, $20, $38
              .byte $35, $38, $30, $00
              
ASCII         .null '¿¡¬√ƒ≈∆‡·‚„‰ÂÊ»… ÀËÈÍÎÃÕŒœÏÌÓÔ“”‘’÷ÿÚÛÙıˆ¯Ÿ⁄€‹˘˙˚¸«Á—Ò›ü˝ˇﬂ'
PETSCII       .null 'AAAAAAAaaaaaaaEEEEeeeeIIIIiiiiOOOOOOooooooUUUUuuuuCcNnYYyyB'

              ;examples special characters:
              ; /HVSC/C64Music/MUSICIANS/W/Walt/Maelkeboetten.sid (MÊclkeb¯tten)
              ; /HVSC/C64Music/MUSICIANS/A/Ass_It/Lasst_Uns_Froh.sid (Laﬂt Uns Froh)
              ; /HVSC/C64Music/GAMES/A-F/Captain_Blood.sid (by FranÁois Lionet)
              ; /HVSC/C64Music/MUSICIANS/D/Da_Blondie/Brain_Damage.sid (by Attila Szıke)
              ; etc.

fileEnd
