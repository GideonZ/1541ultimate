<html lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery.terminal/css/jquery.terminal.min.css"/>
<title>Ultimate II/64</title>
<link rel="icon" href="data:,">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Placeholder to prevent ReferenceError if the profile script calls this function -->
<script>window.initializeTokenizerUI = () => {};</script>
<!-- Load configuration and defines SCRIPT_TO_LOAD for later dynamic loading -->
<script src="SPECIAL.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.terminal/js/jquery.terminal.min.js"></script>

<script>

var serverIP = window.location.hostname;
var apiPassword = "";
var ultimateInfo = {};

$(document).ready(async function () {

    var basic_error = ""; // for error reports during parsing

    async function ensureLoggedIn() {
        // This also works with older firmware that do not support password protection (will get a 404 for /v1/info)
        let [status_code, content] = await make_get_request("http://" + serverIP + "/v1/info");
        if (status_code == 401 || status_code == 403) {
            $("#banner").html("&nbsp;");
            $("#left-nav").css("visibility", "hidden");
            $("#password").val("");
            $(".page").hide();
            $("#login").show();
            $("#password").focus();
        }
        else {
            if (content) {
                ultimateInfo = content;
            }
            let product = ultimateInfo.product ? ultimateInfo.product : "Ultimate II/64";
            if (apiPassword != "") {
                $("#logoutmenuitem").show();
            }
            else {
                $("#logoutmenuitem").hide();
            }
            $("#banner").html(product + " HTTP Server");
            $("#left-nav").css("visibility", "visible");
            $(".page").hide();
            $("#welcome").show();
        }
    };

    $('#loginbutton').click(async function(event){
        apiPassword = $("#password").val();
        await ensureLoggedIn();
    });

    $('#password').on("keypress", async function(event){
        if(event.which == 13) {
            await $("#loginbutton").click();
        }
    });

    $('#logout').click(async function(event){
        apiPassword = "";
        await ensureLoggedIn();
    });

    $('#doreset').click(function(event){
        event.preventDefault(); // Prevents the default action of the anchor tag
        doReset();
    });

    async function doReset() {
        let params = {};
        let [status_code, content] = await make_put_request("http://" + serverIP + "/v1/machine:reset", params);
    };

    $('#doreboot').click(function(event){
        event.preventDefault(); // Prevents the default action of the anchor tag
        doReboot();
    });

    async function doReboot() {
        let params = {};
        let [status_code, content] = await make_put_request("http://" + serverIP + "/v1/machine:reboot", params);
    };

    $('#domenubutton').click(function(event){
        event.preventDefault(); // Prevents the default action of the anchor tag
        doMenuButton();
    });

    async function doMenuButton() {
        let params = {};
        let [status_code, content] = await make_put_request("http://" + serverIP + "/v1/machine:menu_button", params);
    };

    $('#showterminal').click(function(event){
            event.preventDefault(); // Prevents the default action of the anchor tag
            $(".page").hide();
            $('#livemon').show(); // Shows the hidden div
    });

    $('#showwelcome').click(function(event){
            event.preventDefault(); // Prevents the default action of the anchor tag
            $(".page").hide();
            $('#welcome').show();
    });

    // SID page event handlers
    $('#showsidplay').click(function(event){
        event.preventDefault(); // Prevents the default action of the anchor tag
        $(".page").hide();
        $('#sidplay').show();
    });

    $('#sidplaysubmit').click(function(e) {
        e.preventDefault();
        submitSidPlayer();
    });

    $('#sidfile').on("change", function () {
        submitSidPlayer();
    });

    $('#siddropzone').on("dragover", function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).addClass("dragover");
    });

    $('#siddropzone').on("dragleave", function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).removeClass("dragover");
    });

    $('#siddropzone').on("drop", function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).removeClass("dragover");

        const files = e.originalEvent.dataTransfer.files;
        if (files.length > 0) {
            $("#sidfile").prop("files", files);
            submitSidPlayer();
        }
    });

    // PRG/CRT page event handlers
    $('#showrunner').click(function(event){
        event.preventDefault(); // Prevents the default action of the anchor tag
        $(".page").hide();
        $("#runner").show();
    });

    $('#runnersubmit').click(function(e) {
        e.preventDefault();
        submitRunner();
    });

    $('#runnerfile').on("change", function () {
        submitRunner();
    });

    $('#runnerdropzone').on("dragover", function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).addClass("dragover");
    });

    $('#runnerdropzone').on("dragleave", function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).removeClass("dragover");
    });

    $('#runnerdropzone').on("drop", function (e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).removeClass("dragover");

        const files = e.originalEvent.dataTransfer.files;
        if (files.length > 0) {
            $('#runnerfile').prop("files", files);
            submitRunner();
        }
    });

    function getFileExtension(filename) {
        let parts = filename.split('.');
        let extension = parts.length > 1 ? parts[parts.length - 1] : '';
        return extension.toUpperCase();
    }

    async function submitSidPlayer() {
        let body = $('#sidfile')[0].files[0];
        let params = {};
        $("#sidmsg").hide();

        let extension = getFileExtension(body.name);
        if (extension !== "SID") {
            alert("Unsupported file extension: '."+ extension.toLowerCase()+"'");
            return;
        }

        let [status_code, content] = await make_post_request("http://" + serverIP + "/v1/runners:sidplay", params, body);
        if(status_code !== 200) {
            $("#sidmsg").show();
        }
    }

    // PRG/CRT(/SID) loader
    async function submitRunner() {
        let body = $('#runnerfile')[0].files[0];
        let extension = getFileExtension(body.name);
        let params = {};
        $("#runmsg").hide();

        let route = null;
        if (extension === "PRG")
            route = "/v1/runners:run_prg";
        else if (extension === "CRT")
            route = "/v1/runners:run_crt";
        else if (extension === "SID")
            route = "/v1/runners:sidplay";
        else
            alert("Unsupported file extension: '."+ extension.toLowerCase()+"'");

        if (route !== null) {
            let [status_code, content] = await make_post_request("http://" + serverIP + route, params, body);
            if(status_code !== 200)
                $("#runmsg").show();
	}
    }

    // BASIC/tokenizer page event handlers
    function showBASICerror(message) {
        $("#basicmsg").text(message);
        if (message === "")
           $("#basicmsg").hide();
        else
           $("#basicmsg").show();
    }

    $('#showtokenizer').click(function(event){
            event.preventDefault(); // Prevents the default action of the anchor tag
            $(".page").hide();
            $("#tokenizer").show();
    });

    $('#submitBASIC').click(async function(event){
        event.preventDefault(); // Prevents the default action of the anchor tag
        await parseBASIC();
    });

    $('#submitBASICAndRun').click(async function (event) {
        event.preventDefault(); // Prevents the default action of the anchor tag
        if (await parseBASIC() === true)
            await runBASIC();   // Only RUN when parsing/upload was successful
    });

    $('#runBASIC').click(async function (event) {
        event.preventDefault(); // Prevents the default action of the anchor tag
        await runBASIC();
    });

    $('#stopBASIC').click(async function (event) {
        event.preventDefault(); // Prevents the default action of the anchor tag
        await stopBASIC();
    });

    $('#uppercaseBASIC').on('change', async function (event) {
        $("#basiceditor").toggleClass("uppercase", this.checked);  // change upper/lowercase display
    });

    // Custom modal handler to clear the editor without browser interference
    $('#clearBASIC').click(function (event) {
        event.preventDefault(); // Prevents the default action of the button
        $("#customModalOverlay").show(); // Shows the custom modal
    });

    // Action when "Yes" is clicked in the custom modal
    $('#modalYes').click(function () {
        $("#basiceditor").val(""); // Clears the textarea content
        showBASICerror("");        // Hides any existing error messages
        $("#customModalOverlay").hide(); // Hides the modal after clearing
    });

    // Action when "No" (Cancel) is clicked in the custom modal
    $('#modalNo').click(function () {
        $("#customModalOverlay").hide(); // Simply closes the modal without changes
    });

    // convenience: write memory - show error message when access fails
    async function writeMemory(param, errorMsg) {
        showBASICerror(""); // clear earlier errors
        let [status_code, content] = await make_put_request("/v1/machine:writemem", param);
        if (status_code !== 200) {
            if (status_code === 0)
                status_code = "no connection to device";
            showBASICerror(errorMsg+" (error: "+status_code+").");
            return false;
        }
        return true;
    }

    async function runBASIC() {
        // Put "RUN\R" into the keyboard buffer
        if (!await writeMemory({address: "0277", data: "52554E0D"}, "Failed to submit 'RUN' command"))
            return;
        // Set the keyboard buffer to 4 characters
        await writeMemory({address: "00C6", data: "04"}, "Failed to submit 'RUN' command");
    }

    async function stopBASIC() {
        // write the $91 STOP flag several times to reduce issues with a race condition, as the C64 kernal is also writing the flag
        for (var i=0;i<5;i++)
           // Set BASIC STOP key flag $0091
           if (!await writeMemory({address: "0091", data: "7F"}, "Failed to set 'STOP' flag"))
               return; // abort on first error
    }

    async function parseBASIC() {
        var textarea = $("#basiceditor").val();

        // Split into lines, keep only those starting with a digit, and join back
        var lines = textarea.split('\n')
                .map(line => line.trim())
                .filter(line => /^\d/.test(line));

        const tokenized_lines = [];
        let addr = 2049;

        // Clear error before starting
        basic_error = "";

        // Process each line
        for(let x=0; x<lines.length; x++) {
            const currentLineText = lines[x].trim();
            // Correctly extract only the leading digits as line number
            const lineNum = currentLineText.match(/^\d+/)?.[0] || "unknown";

            const tokenizedLine = new TokenizedLine(currentLineText, addr);

            // VALIDATION: Total line size in memory
            let lineTotalLength = tokenizedLine.length();
            if(lineTotalLength > 256) {
                $("#basicmsg").text("Error in line " + lineNum + ". Line too long for C64 memory (" + lineTotalLength + " bytes). Max is 256. Program was not sent.").show();
                return; // Abort processing to prevent memory corruption
            }

            // CHECK: If basic_error was set after processing this specific line
            if(basic_error !== "") {
                showBASICerror("Error in line " + lineNum + ". Program contains errors and was not sent. " + basic_error);
                return false; // Stop execution to prevent sending corrupted data
            }

            addr += lineTotalLength;
            tokenized_lines.push(tokenizedLine);
        }

        let i = 1
        while (i < tokenized_lines.length)
        {
            tokenized_lines[i - 1].next_addr = tokenized_lines[i].addr
            i += 1;
        }

        tokenized_lines[i-1].next_addr = tokenized_lines[i-1].addr + tokenized_lines[i-1].bytes.length + 5;


        var data = convertData(tokenized_lines);

        showBASICerror(basic_error); // show parser error messages (or hide the text box)

        if(basic_error === "") {
            let params = {"address":"0801"};
            let [status_code, content] = await make_post_request("http://" + serverIP + "/v1/machine:writemem", params, data);
        
            if (status_code === 200) {
                let varptr = toHex16(tokenized_lines[i-1].next_addr + 2);
                varptr = varptr.substring(2, 4) + varptr.substring(0, 2);

                params = {"address":"002d", "data": varptr };
                [status_code, content] = await make_put_request("http://" + serverIP + "/v1/machine:writemem", params);
            }

            if (status_code !== 200) {
                if (status_code === 0)
                    status_code = "no connection to device";
                showBASICerror("Upload failed (error: "+status_code+").");
                return false;
            }
            return true;
        }

        return false;
    }

    function getAsciiValues(str) {
        var asciiValues = [];
        for (var i = 0; i < str.length; i++) {
            asciiValues.push(str.charCodeAt(i));
        }
        return asciiValues;
    }

    // Reset textarea to its default HTML value (the error message) on every reload.
    // This prevents the browser from restoring previous session text after F5.
    const editor = document.getElementById('basiceditor');
    if (editor) {
        // Reset to the initial content defined between <textarea> tags in HTML
        editor.value = editor.defaultValue;
    }

    // * Finalizes the initialization process once the external profile script is ready.
    // * This function is triggered only when CBM_SIGNATURE reaches "READY" state.
    const finalizeInitialization = () => {
        // 1. Assign SPECIAL table from the loaded script
        window.SPECIAL = window.SPECIAL || [];
        SPECIAL = window.SPECIAL;

        // 2. Assign TOKENS table from the loaded script
        if (typeof TOKENS !== 'undefined') {
            window.TOKENS = TOKENS;
        } else if (typeof window.TOKENS === 'undefined') {
            window.TOKENS = []; // Fallback if TOKENS are missing
        }

        // 3. Assign TOOLTIP object from the loaded script
        if (typeof TOOLTIP !== 'undefined') {
            window.TOOLTIP = TOOLTIP;
        } else if (typeof window.TOOLTIP === 'undefined') {
            window.TOOLTIP = {}; // Fallback to empty object if TOOLTIP is missing
        }

        // 4. Render tables and initialize specialized UI components
        if (typeof renderSpecialTable === 'function') {
            renderSpecialTable(SPECIAL);
        }

        // 5. Initialize main tokenizer user interface logic
        if (typeof initializeTokenizerUI === 'function') {
            initializeTokenizerUI();
        }

        // 6. Inject predefined BASIC code into the editor
        if (typeof window.BASIC_CODE !== 'undefined' && window.BASIC_CODE !== "") {
            const editor = document.getElementById('basiceditor');
            if (editor) {
                editor.value = window.BASIC_CODE;
                editor.dispatchEvent(new Event('input'));
            }
        }
    };

    // DYNAMIC LOADING LOGIC BASED ON SIGNATURE
    if (typeof SCRIPT_TO_LOAD !== 'undefined' && SCRIPT_TO_LOAD !== "") {
        const script = document.createElement('script');
        script.src = SCRIPT_TO_LOAD;
        document.head.appendChild(script);

        // Polling mechanism: strictly verify if the file is ready via CBM_SIGNATURE
        const checkReady = setInterval(() => {
            if (window.CBM_SIGNATURE === "READY") {
                clearInterval(checkReady);
                finalizeInitialization();
            }
        }, 50);

        // Safety timeout: if READY is not reached, stop polling
        setTimeout(() => {
            if (window.CBM_SIGNATURE !== "READY") {
                clearInterval(checkReady);
                // We do NOT call finalizeInitialization here to keep the error message visible
            }
        }, 3000);
    } else {
        // Fallback: initialize system without external profile
        finalizeInitialization();
    }

    function asciiToPetscii(o) {
        // Check if character code is less than or equal to '@' or is '[' or ']' or '^'
        if (o <= '@'.charCodeAt(0) || o === '['.charCodeAt(0) || o === ']'.charCodeAt(0) || o === '^'.charCodeAt(0)) {
            return o;
        }
        // Check if character code is between 'a' and 'z'
        if (o >= 'a'.charCodeAt(0) && o <= 'z'.charCodeAt(0)) {
            return o - 'a'.charCodeAt(0) + 0x41;
        }
        // Check if character code is between 'A' and 'Z'
        if (o >= 'A'.charCodeAt(0) && o <= 'Z'.charCodeAt(0)) {
            return o - 'A'.charCodeAt(0) + 0x61 + 0x60;
        }

        basic_error = "Error -> ..." + o + " \nUnable to convert to PETSCII value.";
        
    }

    // * Scans the input string for tokens, special characters, or plain text.
    // * @param {string} s - The input string fragment.
    // * @param {boolean} tokenize - Whether to attempt keyword tokenization.
    // * @returns {[number|null, string]} - Array containing the byte value and the remaining string.
    function scan(s, tokenize = true) {
        s = expandCounts(s);

        if (tokenize) {
            for (let i = 0; i < TOKENS.length; i++) {
                let [token, value] = TOKENS[i];
                if (s.startsWith(token)) {
                    return [value, s.substring(token.length)];
                }
            }
        }

        if (s[0] === '{') {
            for (let i = 0; i < SPECIAL.length; i++) {
                let [token, value] = SPECIAL[i];
                if (s.startsWith(token)) {
                    // A null byte (0x00) acts as an absolute end-of-line (EOL) terminator
                    // in Commodore BASIC v2.0. If we encounter {null} (value 0), we return an
                    // empty string to signal the main tokenizer loop to stop processing this line.
                    if (value === 0) {
                        return [0, ""];
                    }
                    return [value, s.substring(token.length)];
                }
            }
            basic_error = "Error -> ..." + s + " \nInvalid special character code occurred from this point.";
            return [null, null];
        }

        // Convert standard character to PETSCII and move to next char
        return [asciiToPetscii(s.charCodeAt(0)), s.substring(1)];
    }

    // * Expands character repetition shorthands into individual tokens.
    // * Supports both historical type-in magazine formats and modern IDE syntax.
    function expandCounts(input) {
        // This regex handles two variants:
        // 1. {3 space} -> format used in "COMPUTE!'s Gazette" magazine
        // 2. {space*3} -> format compatible with CBMprgStudio
        return input.replace(/\{(\d+) ([^}]+)\}|\{([^}]+)\*(\d+)\}/g, (_, count1, word1, word2, count2) => {
            // Extract values from whichever group was matched
            const count = Number(count1 || count2);
            const word = word1 || word2

            // Generates repeated tokens, e.g., {space}{space}{space}
            return Array(count).fill(`{${word}}`).join('');
        });
    }

    function scanLineNumber(s) {
        s = s.trimStart();
        let acc = [];
        while (s && s[0].match(/\d/)) {
            acc.push(s[0]);
            s = s.substring(1);
        }
        return [parseInt(acc.join(''), 10), s.trimStart()];
    }

    // * Converts a BASIC source line into a sequence of C64-compatible bytes.
    // * @param {string} s - The full source line (e.g., "10 PRINT A$").
    // * @returns {[number, number[]]} - Array containing the line number and the tokenized bytes.
    function tokenize(s) {
        // Uses scanLineNumber to correctly handle cases like "10PRINT" (no space after line number)
        let [lineNumber, remainingString] = scanLineNumber(s);
        let bytes = [];

        let inQuotes = false;
        let inRemark = false;
        let inData   = false;

        while (remainingString && remainingString.length > 0) {
            // C64 Logic: Tokenization is disabled inside quotes, REM (comments), or after DATA statements
            let shouldTokenize = !(inQuotes || inRemark || inData);
            let [byte, newString] = scan(remainingString, shouldTokenize);

            // C64 CRITICAL FIX: If a 0x00 byte is generated, terminate the line immediately.
            // This ensures compatibility with the C64 Kernal/BASIC interpreter, which
            // stops parsing the line at the first null byte, regardless of the line pointer.
            if (byte === 0) {
                break;
            }

            if (byte !== null) {
                bytes.push(byte);

                // Mode switching based on standard C64 BASIC v2.0 token values
                if (byte === 34) {          // ASCII/PETSCII for double quotes (")
                    inQuotes = !inQuotes;
                } else if (byte === 143) {  // C64 Token for REM ($8F)
                    inRemark = true;
                } else if (byte === 131) {  // C64 Token for DATA ($83)
                    inData = true;
                }
            }
            remainingString = newString;
        }

        return [lineNumber, bytes];
    }

    class TokenizedLine {
        constructor(s, addr) {
            let [lineNumber, bytes] = tokenize(s); // Ensure tokenize function is defined
            this.lineNumber = lineNumber;
            this.bytes = bytes;
            this.addr = addr;
            //this.nextAddr = null;
        }

        toString() {
            return `${this.lineNumber} @${this.addr}: ${this.bytes}`;
        }

        length() {
            return this.bytes.length + 5;
        }


    }

    function convertData(dataArray) {
        let result = [];

        dataArray.forEach(item => {
            // Extract low and high bytes of the next address and line number
            let nextAddrLowByte = item.next_addr & 0xFF;
            let nextAddrHighByte = (item.next_addr >> 8) & 0xFF;
            let lineNumberLowByte = item.lineNumber & 0xFF;
            let lineNumberHighByte = (item.lineNumber >> 8) & 0xFF;

            // Append to the result
            result.push(nextAddrLowByte, nextAddrHighByte, lineNumberLowByte, lineNumberHighByte);
            result.push(...item.bytes);
            result.push(0); // Terminator
        });
            result.push(0);
        result.push(0);
        
        return new Uint8Array(result);
    }


    $('#basiceditor').on('keypress', function(e) {
            var lines = $(this).val().split('\n');
            var cursorPosition = this.selectionStart;
            var currentLine = 0;
            var currentLineLength = 0;

            for (var i = 0; i < lines.length; i++) {
                currentLineLength += lines[i].length + 1; // +1 for the newline character
                if (cursorPosition <= currentLineLength) {
                    currentLine = i;
                    break;
                }
            }
    });

    // * Renders the C64 Special Characters Table in an 8x32 grid layout.
    // * Design: [Red Separator][HEX][4px Gap][Symbols][16px Gap][Next Column]
    // * Features: Pepto PAL color accuracy and adaptive text contrast for accessibility.
    // * Interaction: Symbols are clickable and insert their token into the BASIC editor.
    function renderSpecialTable() {
        // Reference global tokens list from the external profile
        const tokens = window.SPECIAL;

        // 1. Official Pepto PAL Palette (by Philip Timmermann) for authentic C64 color reproduction
        const colorByHex = {
            0x90: '#000000', 0x05: '#ffffff', 0x1c: '#68372b', 0x9f: '#70a4b2', 0x9c: '#6f3d86', 0x1e: '#588d43', 0x1f: '#352879', 0x9e: '#b8c76f',
            0x81: '#6f4f25', 0x95: '#433900', 0x96: '#9a6759', 0x97: '#444444', 0x98: '#6c6c6c', 0x99: '#9ad284', 0x9a: '#6c5eb5', 0x9b: '#959595'
        };

        // 2. Map all tokens to their respective 0-255 HEX codes
        let grouped = Array.from({ length: 256 }, () => []);
        tokens.forEach(item => {
            if (item.length >= 2) {
                let [symbol, code] = item;
                grouped[code].push(symbol);
            }
        });

        // 3. Build the table using a monospace font to ensure strict vertical alignment
        let $table = $('<table style="font-family: monospace; border-collapse: collapse; background: #f5f5f5; font-size: 13px;"></table>');

        // Create 32 rows to cover the 256 character map across 8 columns
        for (let row = 0; row < 32; row++) {
            let $tr = $('<tr></tr>');
            for (let col = 0; col < 8; col++) {
                // Calculate PETSCII code based on current row and column range
                let code = row + (col * 32);
                let hexDisplay = '0x' + code.toString(16).padStart(2, '0').toUpperCase();

                // Get tooltip description for the current hex code
                const tooltipText = (window.TOOLTIP && window.TOOLTIP[code]) ? window.TOOLTIP[code] : "";

                // Render each symbol associated with the current HEX code
                let formattedSymbols = grouped[code].map(symbol => {
                    let content = symbol.replace(/{|}/g, '');
                    let isNumeric = /^\d+$/.test(content);

                    // Interaction styles: pointer cursor and no text selection
                    const baseStyle = `cursor: pointer; user-select: none;`;

                    if (isNumeric) {
                        // Added title attribute for tooltip
                        return `<span class="special-token" data-token="${symbol}" title="${tooltipText}" style="${baseStyle} color: #000000; padding: 0 2px;">${symbol}</span>`;
                    } else if (colorByHex[code]) {
                        // Render color tokens using the background color from Pepto PAL
                        const bgColor = colorByHex[code];

                        const darkCodes = [0x90, 0x1F, 0x95, 0x1C, 0x97, 0x9C, 0x98, 0x81];
                        const textColor = darkCodes.includes(code) ? '#FFFFFF' : '#000000';

                        // Added title attribute for tooltip
                        return `<span class="special-token" data-token="${symbol}" title="${tooltipText}" style="${baseStyle} background-color: ${bgColor}; color: ${textColor}; font-weight: bold; padding: 1px 4px; border-radius: 2px; display: inline-block; margin: 1px 0; border: 1px solid rgba(0,0,0,0.1);">${symbol}</span>`;
                    } else {
                        // Render functional tokens in standard blue. Added title attribute for tooltip.
                        return `<span class="special-token" data-token="${symbol}" title="${tooltipText}" style="${baseStyle} color: #0000ff; padding: 0 2px;">${symbol}</span>`;
                    }
                }).join(' ');

                // Apply specific spacing
                $tr.append(`
                    <td style="padding-right: 4px; color: #666; border-left: 1px solid red; padding-left: 5px; white-space: nowrap;">${hexDisplay}</td>
                    <td style="padding-right: 8px; white-space: nowrap;">${formattedSymbols}</td>
                `);
            }
            $table.append($tr);
        }

        // Inject the final rendered table into the DOM container
        $('#tableContainer').empty().append($table);

        // 4. Interaction Logic: Insert clicked token into the #basiceditor textarea
        $('.special-token').off('click').on('click', function(e) {
            const token = $(this).data('token');
            const $editor = $('#basiceditor');

            if ($editor.length) {
                const scrollPos = $(window).scrollTop();
                const start = $editor.prop('selectionStart');
                const end = $editor.prop('selectionEnd');
                const oldText = $editor.val();

                const newText = oldText.substring(0, start) + token + oldText.substring(end);
                $editor.val(newText);
                $editor.trigger('input');

                $editor[0].focus({ preventScroll: true });
                $(window).scrollTop(scrollPos);

                const newCursorPos = start + token.length;
                $editor.setSelectionRange(newCursorPos, newCursorPos);
            }
        });
    }

    var memViewAddress = 0;   // "m"emory view command current address
    var memViewRange   = 256; // "m"emory view command: current range
    var disViewAddress = 0;   // "d"isassemble current address
    var disViewRange   = 256; // "d"isassemble current range

    $('.body').terminal({
        help: async function() {

            this.echo("Available commands (with examples):");
            this.echo(" m - memory view ( m | m c000 | m c000 c100 )");
            this.echo(" h - hunt memory ( h c000 c100 4a 30 00 )");
            this.echo(" f - fill memory ( f c000 c100 00 )");
            this.echo(" d - disassemble ( d | d c000 | d c000 c100 )");

        },
        m: async function(start, end) {

            if (typeof start !== 'undefined')
                start = start.toString();
            else
                start = memViewAddress.toString(16); // no start given: continue from the end of previous range

            if (isHexadecimal(start)) {
                start = hexToInt(start);
                if ((typeof end === 'undefined')||(!isHexadecimal(end)))
                    end = start+memViewRange; // no end given: use default range
                else
                {
                    end = hexToInt(end);
                    if (end > start)
                        memViewRange = end-start; // remember current range as new default
                }
                memViewAddress = end; // remember current end address as default for next "m" command
                if (end >= 0x10000)
                {
                    end = 0x10000;
                    memViewAddress = 0; // wrap address
                }
                for (let i = 0; (i < 4096)&&(start < end); i++) {
                    let hex_num = start.toString(16).padStart(4, "0");
                    let size = (start+16 <= end) ? 16 : (end-start);
                    let params = { 'address': hex_num, 'length': size };
                    let [status_code, content] = await make_binary_get_request("http://" + serverIP + "/v1/machine:readmem", params);
                    
                    if (status_code === 200) {
                        let [hex_content, ascii_content] = format_bytes_as_hex_and_ascii(content);
                        hex_content = hex_content.padEnd(16*3, " ");
                        this.echo(`${hex_num}: ${hex_content} | ${ascii_content}`);
                    } else {
                        this.echo("Failed to read memory or invalid response length");
                    }
                    start += 16;
                }
            } else {
                this.echo("Invalid hexadecimal number. Please enter a 16-bit hexadecimal number.");
            }
        },

        h: async function(start, end, ...hunt) {

            if(isHexadecimal(start) && isHexadecimal(end)) {

                let result = areAllValuesInRange(hunt);
                let startInt = hexToInt(start);
                let endInt = hexToInt(end);

                if(result == true) {
                    
                    let params = { 'address': '0', 'length': '65535' };
                    let [status_code, content] = await make_binary_get_request("http://" + serverIP + "/v1/machine:readmem", params);

                    if (status_code === 200) {
                        hunt = hunt.map(hex => hexToInt(hex));
                        let indices = findConsecutiveValues(content, hunt, startInt, endInt)
                        for(let x=0; x<indices.length; x++)
                            this.echo(`${toHex16(indices[x])}`);
                    } else {
                        this.echo("Failed to read memory or invalid response length");
                    }

                }
                else {
                    this.echo("Invalid values.")
                }
            }
            else {
                this.echo("Usage: h <start addr> <end addr> <xx xx ...>");
            }
                
        },
        f: async function(start, end, byte) {

            if(isHexadecimal(start) && isHexadecimal(end)) {

                let startInt = hexToInt(start);
                let endInt = hexToInt(end);
                let hbyte = hexToInt(byte);
                let size = (endInt - startInt) + 1;
                
                let body = new Uint8Array(size);
                body.fill(hbyte);
                    
                let params = { 'address': start};
                let [status_code, content] = await make_post_request("http://" + serverIP + "/v1/machine:writemem", params, body);

                if (status_code !== 200) {
                    
                    this.echo("Failed to update memory");
                }


            }
            else {
                this.echo("Usage: f <start addr> <end addr> <xx>");
            }
                
        },
        d: async function(start, end) {

            if (typeof start !== 'undefined')
                start = start.toString();
            else
                start = disViewAddress.toString(16); // no start given: continue from the end of previous range

            if(isHexadecimal(start)) {
                start = hexToInt(start);
                if ((typeof end === 'undefined')||(!isHexadecimal(end)))
                    end = start+disViewRange; // no end given: use default range
                else
                {
                    end = hexToInt(end.toString());
                    if (end > start)
                        disViewRange = end-start; // remember current range as new default
                }
                disViewAddress = end; // remember current end address as default for next "d" command
                if (end >= 0x10000)
                {
                    end = 0x10000;
                    disViewAddress = 0; // wrap address
                }

                let size = end - start;
                if (size > 0) {
                    disViewRange = end-start; // remember length as default for next "d" command

                    let params = { 'address': start.toString(16), 'length': size };
                    let [status_code, content] = await make_binary_get_request("http://" + serverIP + "/v1/machine:readmem", params);

                    if (status_code === 200) {
                        let result = disassembler(start, content);
                        this.echo(result);
                    }
                }
            }
            else {
                this.echo("Invalid hexadecimal number. Please enter a 16-bit hexadecimal number.");
            }
        }

    }, {
        checkArity: false,
        greetings: 'Ultimate 64 / II+ Remote Monitor\nhelp = list of commands\n'
    });

    // Kick off login/welcome screen as needed
    await ensureLoggedIn();
});

function isHexadecimal(str)
{
    hexval = false;
    regexp = /^[0-9a-fA-F]+$/;
  
    if (regexp.test(str))
        return true;
    else
        return false;

}

function toHex16(num) {
    return num.toString(16).padStart(4, '0').toUpperCase();
}

function toHex8(num) {
    return num.toString(16).padStart(2, '0').toUpperCase();
}

function hexToInt(hexString) {
    return parseInt(hexString, 16);
}

function areAllValuesInRange(hexArray) {
    for (let hex of hexArray) {
        let value = parseInt(hex, 16); // Convert hex to decimal
        if (value < 0 || value > 255) {
            return false; // Value is out of range
        }
    }
    return true; // All values are in range
}

function hex_increment(hex_str, increment=8) {
    return (parseInt(hex_str, 16) + increment).toString(16).padStart(4, '0');
}

function format_bytes_as_hex_and_ascii(byteData) {
    const hexContent = [];
    const asciiContent = [];

    for (const byte of byteData) {
        hexContent.push(byte.toString(16).padStart(2, '0'));

        // Printable ASCII characters are in the range 32 to 126
        if (byte >= 32 && byte <= 126) {
            asciiContent.push(String.fromCharCode(byte));
        } else {
            asciiContent.push('.');
        }
    }

    return [hexContent.join(' '), asciiContent.join('')];
}

function findConsecutiveValues(byteArray, valuesToFind, startIndex, endIndex) {
    const indices = [];
    const sequenceLength = valuesToFind.length;

    // Ensure start and end indices are within the array bounds
    startIndex = Math.max(startIndex, 0);
    endIndex = Math.min(endIndex, byteArray.length - sequenceLength);

    for (let i = startIndex; i <= endIndex; i++) {
        let match = true;
        for (let j = 0; j < sequenceLength; j++) {
            if (byteArray[i + j] !== valuesToFind[j]) {
                match = false;
                break;
            }
        }
        if (match) {
            indices.push(i);
        }
    }

    return indices;
}

$.ajaxTransport("+binary", function (options, originalOptions, jqXHR) {
    // check for conditions and support for blob / arraybuffer response type
    if (window.FormData && ((options.dataType && (options.dataType == 'binary')) ||
         (options.data && ((window.ArrayBuffer && options.data instanceof ArrayBuffer) || 
            (window.Blob && options.data instanceof Blob))))) {
        return {
            // create new XMLHttpRequest
            send: function (headers, callback) {
                // setup all variables
                var xhr = new XMLHttpRequest(),
                    url = options.url,
                    type = options.type,
                    async = options.async || true,
                    // blob or arraybuffer. Default is blob
                    dataType = options.responseType || "blob",
                    data = options.data || null,
                    username = options.username || null,
                    password = options.password || null;

                xhr.addEventListener('load', function () {
                    var data = {};
                    data[options.dataType] = xhr.response;
                    // make callback and send data
                    callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());
                });

                xhr.open(type, url, async, username, password);

                // setup custom headers
                for (var i in headers) {
                    xhr.setRequestHeader(i, headers[i]);
                }

                xhr.responseType = dataType;
                xhr.send(data);
            },
            abort: function () {
                jqXHR.abort();
            }
        };
    }
});

async function make_binary_get_request(url, params) {
    const queryString = Object.entries(params).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join('&');
    const fullUrl = `${url}?${queryString}`;

    console.log('Requesting URL:', fullUrl);

    try {
        const response = await $.ajax({
            url: fullUrl,
            method: 'GET',
            dataType: 'binary',
            responseType: 'arraybuffer',
            processData: false,
            headers: {"X-Password": apiPassword}
        });

       var data = new Uint8Array(response);

        return [200, data];
    } catch (error) {
        console.error("Error fetching data:", error);
        console.log('Error details:', {
            textStatus: error.statusText,
            status: error.status,
            responseText: error.responseText
        });

        const statusCode = error && error.status ? error.status : 500;
        return [statusCode, new Uint8Array()];
    }
}

async function make_get_request(url, params) {
    params = params || {};
    const queryString = Object.entries(params).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join('&');
    const fullUrl = `${url}?${queryString}`;

    console.log('Requesting URL:', fullUrl);

    try {
        const response = await $.ajax({
            url: fullUrl,
            method: 'GET',
            processData: false,
            headers: {"X-Password": apiPassword}
        });
        return [200, response];
    } catch (error) {
        console.error("Error fetching data:", error);
        console.log('Error details:', {
            textStatus: error.statusText,
            status: error.status,
            responseText: error.responseText
        });
        return [error.status, error.responseText];
    }
}

async function make_post_request(url, params, body) {
    const queryString = Object.entries(params).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join('&');
    const fullUrl = `${url}?${queryString}`;

    try {
        const response = await $.ajax({
            url: fullUrl,
            method: 'POST',
            contentType: 'application/octet-stream',
            data: body,
            processData: false,
            headers: {"X-Password": apiPassword}
        });

        return [200, response];
    } catch (error) {
        console.error("Error fetching data:", error);
        console.log('Error details:', {
            textStatus: error.statusText,
            status: error.status,
            responseText: error.responseText
        });
        return [error.status, error.responseText];
        //const statusCode = error && error.status ? error.status : 500;
        //return [statusCode, response];
    }
}

async function make_put_request(url, params) {
    const queryString = Object.entries(params).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join('&');
    const fullUrl = `${url}?${queryString}`;

    try {
        const response = await $.ajax({
            url: fullUrl,
            method: 'PUT',
            contentType: 'application/octet-stream',
            processData: false,
            headers: {"X-Password": apiPassword}
        });

        return [200, response];
    } catch (error) {
        console.error("Error fetching data:", error);
        console.log('Error details:', {
            textStatus: error.statusText,
            status: error.status,
            responseText: error.responseText
        });
        return [error.status, error.responseText];
        //const statusCode = error && error.status ? error.status : 500;
        //return [statusCode, response];
    }
}

const opcodes = {
	"00": {"code": "BRK", "len": 0, "addr": 0},
	"01": {"code": "ORA", "len": 1, "addr": 11},
	"05": {"code": "ORA", "len": 1, "addr": 3},
	"06": {"code": "ASL", "len": 1, "addr": 3},
	"08": {"code": "PHP", "len": 0, "addr": 0},
	"09": {"code": "ORA", "len": 1, "addr": 2},
	"0a": {"code": "ASL", "len": 0, "addr": 1},
	"0d": {"code": "ORA", "len": 2, "addr": 7},
	"0e": {"code": "ASL", "len": 2, "addr": 7},
	"10": {"code": "BPL", "len": 1, "addr": 6},
	"11": {"code": "ORA", "len": 1, "addr": 12},
	"15": {"code": "ORA", "len": 1, "addr": 4},
	"16": {"code": "ASL", "len": 1, "addr": 4},
	"18": {"code": "CLC", "len": 0, "addr": 0},
	"19": {"code": "ORA", "len": 2, "addr": 9},
	"1d": {"code": "ORA", "len": 2, "addr": 8},
	"1e": {"code": "ASL", "len": 2, "addr": 8},
	"20": {"code": "JSR", "len": 2, "addr": 7},
	"21": {"code": "AND", "len": 1, "addr": 11},
	"24": {"code": "BIT", "len": 1, "addr": 3},
	"25": {"code": "AND", "len": 1, "addr": 3},
	"26": {"code": "ROL", "len": 1, "addr": 3},
	"28": {"code": "PLP", "len": 0, "addr": 0},
	"29": {"code": "AND", "len": 1, "addr": 2},
	"2a": {"code": "ROL", "len": 0, "addr": 1},
	"2c": {"code": "BIT", "len": 2, "addr": 7},
	"2d": {"code": "AND", "len": 2, "addr": 7},
	"2e": {"code": "ROL", "len": 2, "addr": 7},
	"30": {"code": "BMI", "len": 1, "addr": 6},
	"31": {"code": "AND", "len": 1, "addr": 12},
	"35": {"code": "AND", "len": 1, "addr": 4},
	"36": {"code": "ROL", "len": 1, "addr": 4},
	"38": {"code": "SEC", "len": 0, "addr": 0},
	"39": {"code": "AND", "len": 2, "addr": 9},
	"3d": {"code": "AND", "len": 2, "addr": 8},
	"3e": {"code": "ROL", "len": 2, "addr": 8},
	"40": {"code": "RTI", "len": 0, "addr": 0},
	"41": {"code": "EOR", "len": 1, "addr": 11},
	"45": {"code": "EOR", "len": 1, "addr": 3},
	"46": {"code": "LSR", "len": 1, "addr": 3},
	"48": {"code": "PHA", "len": 0, "addr": 0},
	"49": {"code": "EOR", "len": 1, "addr": 2},
	"4a": {"code": "LSR", "len": 0, "addr": 1},
	"4c": {"code": "JMP", "len": 2, "addr": 7},
	"4d": {"code": "EOR", "len": 2, "addr": 7},
	"4e": {"code": "LSR", "len": 2, "addr": 7},
	"50": {"code": "BVC", "len": 1, "addr": 6},
	"51": {"code": "EOR", "len": 1, "addr": 12},
	"54": {"code": "EOR", "len": 1, "addr": 4},
	"55": {"code": "LSR", "len": 1, "addr": 4},
	"58": {"code": "CLI", "len": 0, "addr": 0},
	"59": {"code": "EOR", "len": 2, "addr": 9},
	"5d": {"code": "EOR", "len": 2, "addr": 8},
	"5e": {"code": "LSR", "len": 2, "addr": 8},
	"60": {"code": "RTS", "len": 0, "addr": 0},
	"61": {"code": "ADC", "len": 1, "addr": 11},
	"65": {"code": "ADC", "len": 1, "addr": 3},
	"66": {"code": "ROR", "len": 1, "addr": 3},
	"68": {"code": "PLA", "len": 0, "addr": 0},
	"69": {"code": "ADC", "len": 1, "addr": 2},
	"6a": {"code": "ROR", "len": 0, "addr": 1},
	"6c": {"code": "JMP", "len": 2, "addr": 10},
	"6d": {"code": "ADC", "len": 2, "addr": 7},
	"6e": {"code": "ROR", "len": 2, "addr": 7},
	"70": {"code": "BVS", "len": 1, "addr": 6},
	"71": {"code": "ADC", "len": 1, "addr": 12},
	"75": {"code": "ADC", "len": 1, "addr": 4},
	"76": {"code": "ROR", "len": 1, "addr": 4},
	"78": {"code": "SEI", "len": 0, "addr": 0},
	"79": {"code": "ADC", "len": 2, "addr": 9},
	"7d": {"code": "ADC", "len": 2, "addr": 8},
	"7e": {"code": "ROR", "len": 2, "addr": 8},
	"81": {"code": "STA", "len": 1, "addr": 11},
	"84": {"code": "STY", "len": 1, "addr": 3},
	"85": {"code": "STA", "len": 1, "addr": 3},
	"86": {"code": "STX", "len": 1, "addr": 3},
	"88": {"code": "DEY", "len": 0, "addr": 0},
	"8a": {"code": "TXA", "len": 0, "addr": 0},
	"8c": {"code": "STY", "len": 2, "addr": 7},
	"8d": {"code": "STA", "len": 2, "addr": 7},
	"8e": {"code": "STX", "len": 2, "addr": 7},
	"90": {"code": "BCC", "len": 1, "addr": 6},
	"91": {"code": "STA", "len": 1, "addr": 12},
	"94": {"code": "STY", "len": 1, "addr": 4},
	"95": {"code": "STA", "len": 1, "addr": 4},
	"96": {"code": "STX", "len": 1, "addr": 5},
	"98": {"code": "TYA", "len": 0, "addr": 0},
	"99": {"code": "STA", "len": 2, "addr": 9},
	"9a": {"code": "TXS", "len": 0, "addr": 0},
	"9d": {"code": "STA", "len": 2, "addr": 8},
	"a0": {"code": "LDY", "len": 1, "addr": 2},
	"a1": {"code": "LDA", "len": 1, "addr": 11},
	"a2": {"code": "LDX", "len": 1, "addr": 2},
	"a4": {"code": "LDY", "len": 1, "addr": 3},
	"a5": {"code": "LDA", "len": 1, "addr": 3},
	"a6": {"code": "LDX", "len": 1, "addr": 3},
	"a8": {"code": "TAY", "len": 0, "addr": 0},
	"a9": {"code": "LDA", "len": 1, "addr": 2},
	"aa": {"code": "TAX", "len": 0, "addr": 0},
	"ac": {"code": "LDY", "len": 2, "addr": 7},
	"ad": {"code": "LDA", "len": 2, "addr": 7},
	"ae": {"code": "LDX", "len": 2, "addr": 7},
	"b0": {"code": "BCS", "len": 1, "addr": 6},
	"b1": {"code": "LDA", "len": 1, "addr": 12},
	"b4": {"code": "LDY", "len": 1, "addr": 4},
	"b5": {"code": "LDA", "len": 1, "addr": 4},
	"b6": {"code": "LDX", "len": 1, "addr": 5},
	"b8": {"code": "CLV", "len": 0, "addr": 0},
	"b9": {"code": "LDA", "len": 2, "addr": 9},
	"ba": {"code": "TSX", "len": 0, "addr": 0},
	"bc": {"code": "LDY", "len": 2, "addr": 8},
	"bd": {"code": "LDA", "len": 2, "addr": 8},
	"be": {"code": "LDX", "len": 2, "addr": 9},
	"c0": {"code": "CPY", "len": 1, "addr": 2},
	"c1": {"code": "CMP", "len": 1, "addr": 11},
	"c4": {"code": "CPY", "len": 1, "addr": 3},
	"c5": {"code": "CMP", "len": 1, "addr": 3},
	"c6": {"code": "DEC", "len": 1, "addr": 3},
	"c8": {"code": "INY", "len": 0, "addr": 0},
	"c9": {"code": "CMP", "len": 1, "addr": 2},
	"ca": {"code": "DEX", "len": 0, "addr": 0},
	"cc": {"code": "CPY", "len": 2, "addr": 7},
	"cd": {"code": "CMP", "len": 2, "addr": 7},
	"ce": {"code": "DEC", "len": 2, "addr": 7},
	"d0": {"code": "BNE", "len": 1, "addr": 6},
	"d1": {"code": "CMP", "len": 1, "addr": 12},
	"d5": {"code": "CMP", "len": 1, "addr": 4},
	"d6": {"code": "DEC", "len": 1, "addr": 4},
	"d8": {"code": "CLD", "len": 0, "addr": 0},
	"d9": {"code": "CMP", "len": 2, "addr": 9},
	"dd": {"code": "CMP", "len": 2, "addr": 8},
	"de": {"code": "DEC", "len": 2, "addr": 8},
	"e0": {"code": "CPX", "len": 1, "addr": 2},
	"e1": {"code": "SBC", "len": 1, "addr": 11},
	"e4": {"code": "CPX", "len": 1, "addr": 3},
	"e5": {"code": "SBC", "len": 1, "addr": 3},
	"e6": {"code": "INC", "len": 1, "addr": 3},
	"e8": {"code": "INX", "len": 0, "addr": 0},
	"e9": {"code": "SBC", "len": 1, "addr": 2},
	"ea": {"code": "NOP", "len": 0, "addr": 0},
	"ec": {"code": "CPX", "len": 2, "addr": 7},
	"ed": {"code": "SBC", "len": 2, "addr": 7},
	"ee": {"code": "INC", "len": 2, "addr": 7},
	"f0": {"code": "BEQ", "len": 1, "addr": 6},
	"f1": {"code": "SBC", "len": 1, "addr": 12},
	"f5": {"code": "SBC", "len": 1, "addr": 4},
	"f6": {"code": "INC", "len": 1, "addr": 4},
	"f8": {"code": "SED", "len": 0, "addr": 0},
	"f9": {"code": "SBC", "len": 2, "addr": 9},
	"fd": {"code": "SBC", "len": 2, "addr": 8},
	"fe": {"code": "INC", "len": 2, "addr": 8},
};

function disassembler(startInt, byteArray) {
	var result = "";
	var instruction = "";
	var operand = "";
	
	var address;
	var instructionBytes;
	var syntax;
	
	var startingAddr = 0;

    hexString = Array.from(byteArray, byte => byte.toString(16).padStart(2, '0')).join('');
	
	for(pc = 0; pc < hexString.length;pc+=2){
		operand = "";
		address = "";
		instructionBytes = "";
		syntax = "";
		
		address = (pc/2).toString(16);
		startingAddr = pc;
		
		if(!opcodes.hasOwnProperty(hexString.substring(pc,pc+2))){
			instruction = {"code": "???", "len": 0, "addr": 0};
		} else{
			instruction = opcodes[hexString.substring(pc,pc+2)];
		}
		
		//Retrieve operands (if there are any); Note: 6502 is little-endian
		if(instruction.len > 0){
			for(i = 0; i < instruction.len; i++){
				pc+=2;
				operand =  hexString.substring(pc,pc+2) + operand;
			}
		} else {
			operand = hexString.substring(pc,pc+2);
		}
		
		syntax += instruction.code;
		
		switch(instruction.addr){
			case 0: //If Implict
				break;
			case 1: //If Accumulator
				syntax += " A";
				break;
			case 2: //If Immediate
				syntax += " #$" + operand;
				break;
			case 3: //If Zero Page
				syntax += " $" + operand;
				break;
			case 4: //If Zero Page,X
				syntax += " $" + operand + ",X";
				break;
			case 5: //If Zero Page,Y
				syntax += " $" + operand + ",Y";
				break;
			case 6: //If Relative
				syntax += " $" + operand;
				break;
			case 7: //If Absolute
				syntax += " $" + operand;
				break;
			case 8: //If Absolute,X
				syntax += " $" + operand + ",X";
				break;
			case 9: //If Absolute,Y
				syntax += " $" + operand + ",Y";
				break;
			case 10: //If Indirect
				syntax += " ($" + operand + ")";
				break;
			case 11: //If Indexed Indirect
				syntax += " ($" + operand + ",X)";
				break;
			case 12: //If Indirect Indexed
				syntax += " ($" + operand + "),Y";
				break;
		}
		
		//Pad out address to 4 bytes
		while(address.length < 8){
			address = "0" + address;
		}
		
		//Set hexstring from for full instruction
		instructionBytes = hexString.substring(startingAddr,pc+2);
		
		const paddedString = instructionBytes.padEnd(6, ' ');

        // Insert spaces after every second character
        const formattedBytes = paddedString.match(/.{1,2}/g).join(' ');
        

		result += "\n" + toHex16(hexToInt(address) + startInt) + ":" + formattedBytes + "  " + syntax
		
	}
	
	return result;
};

</script>

<style>

    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
    }
    #banner {
        background: linear-gradient(to bottom, #0000FF, #0195c7); /* Dark blue to light blue */
        color: white;
        text-align: left;
        padding: 10px;
        font-size: 24px;
    }
    #content {
        display: flex;
        flex: 1;
    }
    #left-nav {
        width: 200px;
        background-color: #f2f2f2;
        padding: 20px;
        visibility: hidden;
    }
    div#left-nav a {
        color: blue;
        text-decoration: none;
    }
    div#left-nav a:hover {
        background-color: #beffff;
    }
    #login {
        padding: 20px;
        width: 800px;
        display: none;
    }
    #welcome {
        padding: 20px;
        width: 800px;
        display: none;
    }
    #livemon {
        flex-grow: 1;
        padding: 20px;
        display:none;
    }
    #sidplay {
        flex-grow: 1;
        padding: 20px;
        display:none;
    }
    .dropzone {
        max-width: 600px;
        min-height: 120px;
        border: 2px dashed #1966be;
        border-radius: 6px;
        text-align: center;
        color: #666;
        margin-top: 15px;
        padding: 20px 10px;
    }
    .dropzone.dragover {
        border-color: #4caf50;
        color: #4caf50;
        background-color: #f6fff6;
    }
    #runner {
        flex-grow: 1;
        padding: 20px;
        display:none;
    }
    #tokenizer {
        flex-grow: 1;
        padding: 20px;
        display:none;
    }
    #sidmsg {
        flex-grow: 1;
        margin-top: 20px;
        padding: 20px;
        display:none;
        background-color: red;
        color: white;
        width: 400px;
    }
    #runmsg {
        flex-grow: 1;
        margin-top: 20px;
        padding: 20px;
        display:none;
        background-color: red;
        color: white;
        width: 400px;
    }
    #basicmsg {
        flex-grow: 1;
        margin-top: 20px;
        padding: 20px;
        display:none;
        background-color: red;
        color: white;
        width: 400px;
    }
    #uppercaseBASIC {
        margin-left: 20px;
    }
    .uppercase {
        text-transform: uppercase;
    }
    .c64-textarea:focus {
        outline: none;
    }
    button, input[type="button"], input[type="password"], input[type="file"]::file-selector-button {
        padding: 5px 10px;
        font-size: 14px;
    }
    li {
	margin: 5px 0;
    }

    @font-face {
            font-family: 'C64';
            src: url('C64_Pro-STYLE.woff') format('woff'); /* Path to your C64 font file */
        }

        .padding-tr-5 {
            padding-top: 5px;
            padding-right: 5px;
        }

        .c64-textarea {
            font-family: monospace;
            background-color: #1966be; /* Commodore 64 screen color */
            color: #68bee6; /* Light blue text color */
            border-style: solid;
            border-color: #68bee6;
            border-width: 20px 13px;
            border-radius: 0;
            padding: 10px;
            font-size: 16px;
            line-height: 1.5;
            width: 900px;
            height: 400px;
            resize: none;
        }

.trinity-dialog {
    --size: 1.4;
    --background: black;
    --color: rgba(160, 182, 247, 0.877);
    border: 2px solid var(--color);
    background: var(--background);
    width: 800px;
    height: 400px;
    min-height: 100px;
    min-width: 250px;
    max-width: calc(100vw - 40px);
    max-height: calc(100vh - 40px);
    z-index: 100;
    resize: both;
    overflow: auto;
}
.trinity-dialog .body {
    width: 100%;
    height: calc(100% - 28px);
}
.trinity-dialog, .trinity-dialog header .title {
    position: relative;
    left: 420px;
    top: 200px;
    transform: translate(-50%, -50%);
}
.trinity-dialog header .title {
    margin-top: -2px;
    background: var(--color);
    padding: 1px 10px;
}
.trinity-dialog header {
    background: var(--color);
    position: relative;
}
.trinity-dialog header::before {
    content: "";
    display: block;
    position: absolute;
    left: 55px;
    top: 5px;
    right: 10px;
    width: calc(100% - 55px - 5px);
    height: 15px;
    background: #251180;
}
.trinity-dialog header .title::before {
    content: "[ ";
}
.trinity-dialog header .title::after {
    content: " ]";
}
.trinity-dialog header ul {
    margin: 0;
    padding: 0;
    list-style: none;
    display: inline-block;
}
.trinity-dialog header li {
    display: inline-block;
    margin: 3px;
    width: 14px;
    height: 14px;
    border: 2px solid var(--background);
}

</style>



</head>
<body>
    <div id="banner">&nbsp;</div>

    <div id="content">
        <div id="left-nav">
            <ul>
                <li><a id="showwelcome" href="#">Home</a></li>
                <li><a id="showsidplay" href="#">SID Player</a></li>
                <li><a id="showrunner" href="#">Execute PRG / CRT</a></li>
                <li><a id="showterminal"  href="#">Live Monitor</a></li>
                <li><a id="showtokenizer"  href="#">BASIC Editor</a></li>
            </ul>
            <ul>
                <li><a id="doreset" href="#">Reset Machine</a></li>
                <li><a id="doreboot" href="#">Reboot Machine</a></li>
                <li><a id="domenubutton" href="#">Menu Button</a></li>
            </ul>
            <ul>
                <li><a href="https://1541u-documentation.readthedocs.io/en/latest/api/api_calls.html" target="_blank" rel="noopener">API Documentation</a></li>
                <li><a href="https://ultimate64.com/Firmware" target="_blank" rel="noopener">Firmware Releases</a></li>
            </ul>
            <ul id="logoutmenuitem">
                <li><a id="logout" href="#">Logout</a></li>
            </ul>
        </div>

        <div id="login" class="page">
            <h2>Password required</h2>
            <input id="password" type="password">
            <button id="loginbutton" type="button">Login</button>
        </div>

        <div id="welcome" class="page">
            <h1>Welcome to your Ultimate product!</h1>
            <p>This site serves as the dedicated web server 
                for the Ultimate 64 and Ultimate cartridge systems. It offers a comprehensive suite of APIs, designed to 
                enable the development of advanced integrations and remote access to your system.</p>
            <p>You can find out more by visiting the official <a href="https://ultimate64.com/" target="_blank" rel="noopener"> Ultimate 64 website</a>,
                or by joining our <a href="https://www.facebook.com/groups/ultimate64" target="_blank" rel="noopener">Facebook group</a>.
            </p>
            <p>
                Thank you for joining and contributing to the Ultimate family of products.
            </p>
            <p>Gideon Z.</p>
        </div>

        <div id="sidplay" class="page">
            <h1>SID Player</h1>
            <p>Remotely play a SID file on your Ultimate!</p>

            <div id="siddropzone" class="dropzone" title="Drop SID file to be loaded here">
                Drag & drop SID file here
                <br />
                <p style="font-size: 4em">&#x1F3B6;</p>
                <br />
                or press button to browse
                <br /><br />
                <input type="file" id="sidfile" name="file" accept=".sid,.SID" title="Select SID sound file to be played">
                <br /><br />
                <input type="button" id="sidplaysubmit" value="Play Again!" title="Upload and play the selected SID sound file again">
            </div>

            <div id="sidmsg">An error has occurred when uploading the selected file.</div>
        </div>

        <div id="runner" class="page">
            <h1>PRG / CRT Executor</h1>
            <p>Remotely load a program or cartridge to your Ultimate!</p>

            <div id="runnerdropzone" class="dropzone" title="Drop file to be loaded here">
                Drag & drop PRG or CRT file here
                <br />
                <p style="font-size: 4em">&#x21EA;</p>
                <br />
                or press button to browse
                <br /><br />
                <input type="file" id="runnerfile" name="file" accept=".prg,.crt,.PRG,.CRT,.sid,.SID" title="Select PRG/CRT/SID file to be run">
                <br /><br />
                <input type="button" id="runnersubmit" value="Run Again!" title="Upload and RUN the selected file again">
            </div>

            <div id="runmsg">An error has occurred when loading the selected file.</div>
        </div>

        <div id="livemon" class="page">
            <h1>Live Monitor</h1>
            <p>Below is a simple 6510 monitor attached to your U64 or UII+.</p>
            <div id="terminal" class="trinity-dialog">
                <header>
                    <ul>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                    </ul>
                    <span class="title">Ultimate 64</span>
                </header>
                <div class="body"></div>
            </div>
            <div>
                <br />
                <table>
                    <thead>
                        <tr>
                            <b>Available commands (with examples):</b>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>m</td><td>- memory view</td><td>( m | m c000 | m c000 c100 )</td></tr>
                        <tr><td>h</td><td>- hunt memory</td><td>( h c000 c100 4a 30 00 )</td></tr>
                        <tr><td>f</td><td>- fill memory</td><td>( f c000 c100 00 )</td></tr>
                        <tr><td>d</td><td>- disassemble</td><td>( d | d c000 | d c000 c100 )</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="tokenizer" class="page">
            <h1>BASIC Editor / Tokenizer</h1>
            <p>Here, you may enter a BASIC program (type in lower case, abbreviation is allowed), and upload it directly to your machine.</p>

<textarea id="basiceditor" spellcheck="false" autocorrect="off" autocapitalize="off" wrap="off" class="c64-textarea">
Data loading failed: please try reloading the page (Ctrl+F5).
Check for syntax errors in /Flash/html/SPECIAL.js,
or your custom profile if modified.
</textarea>

            <div class="padding-tr-5">
                <span class="padding-tr-5"><input type="button" id="submitBASIC" value="Upload" title="Upload program to C64 memory"></span>
                <span class="padding-tr-5"><input type="button" id="submitBASICAndRun" value="Upload and Run"  title="Upload program to C64 memory and RUN"></span>
                <span class="padding-tr-5"><input type="button" id="runBASIC" value="Run" title="Send RUN command to the C64"></span>
                <span class="padding-tr-5"><input type="button" id="stopBASIC" value="Stop" title="Send STOP command to the C64"></span>
                <span class="padding-tr-5"><input type="button" id="clearBASIC" value="Clear" title="Clear the editor content"></span>
                <input type="checkbox" id="uppercaseBASIC"><label for="uppercaseBASIC" title="Toggle uppercase/lowercase display of BASIC program text">Uppercase</label>
            </div>

            <div id="basicmsg">An error has occurred. Check for valid codes.</div>

            <br />
            <div><b>Special characters: Tokenization codes (0x00 - 0xFF) for Basic</b></div>
            <div id="tableContainer"></div>

        </div>
    </div>
    <style>
        /* Small floating window centered on the screen */
        #customModalOverlay {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Perfect centering */
            z-index: 1000;
        }
        #customModal {
            background: #333; /* Dark background matching the terminal */
            color: #fff;      /* White text */
            padding: 20px;
            border: 2px solid #fff; /* Retro border */
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            font-family: sans-serif;
        }
        .modal-btns { margin-top: 15px; }
        .modal-btns button {
            padding: 5px 15px;
            cursor: pointer;
            margin: 0 5px;
            background: #444;
            color: white;
            border: 1px solid #999;
        }
        .modal-btns button:hover { background: #666; }
    </style>
    <div id="customModalOverlay">
        <div id="customModal">
            <p>Are you sure you want to clear the editor window?</p>
            <div class="modal-btns">
                <button id="modalYes">Yes</button>
                <button id="modalNo">No</button>
            </div>
        </div>
    </div>
</body>
</html>
