<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.0" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
<name>nios</name>
<peripherals>
<peripheral>
      <name>nios_timer_1_s1_altera_avalon_timer</name><baseAddress>0x00000000</baseAddress> 
      <addressBlock>
        <offset>0x0</offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
       <registers>
         <register>     
          <name>status</name>  
          <displayName>Status</displayName>
          <description>The status register has two defined bits. TO (timeout), RUN</description>
          <addressOffset>0x0</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xffff</resetMask>
          <fields>
            <field><name>TO</name>
            <description>The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a timeout event, the TO bit stays set until explicitly cleared by a master peripheral. Write zero to the status register to clear the TO bit.</description>
             <bitOffset>0x0</bitOffset>
             <bitWidth>1</bitWidth>
             <access>read-only</access>
             <readAction>clear</readAction>
            </field>
            <field><name>RUN</name>
            <description>The RUN bit reads as 1 when the internal counter is running; otherwise this bit reads as 0. The RUN bit is not changed by
 a write operation to the status register.</description>
             <bitOffset>1</bitOffset>
             <bitWidth>1</bitWidth>
             <access>read-only</access>
            </field>
            <field>
             <name>Reserved</name>
             <description>Reserved</description>
             <bitOffset>2</bitOffset>
             <bitWidth>14</bitWidth>
             <access>read-write</access>
             <parameters>
                 <parameter>
                 <name>Reserved</name>
                 <value>true</value>
                 </parameter>
             </parameters>
            </field>
          </fields>
        </register> 
        <register>
            <name>control</name>
            <description>The control register has four defined bits. ITO (Timeout Interrupt), CONT (continue), START, STOP</description>
            <addressOffset>0x1</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <reset>
                <value>0x0</value>
            </reset>
            <field>
                <name>ITO</name>
                <description>If the ITO bit is 1, the interval timer core generates an IRQ when the status register's TO bit is 1. When the ITO bit is 0, the timer does not generate IRQs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
            </field>
            <field>
                <name>CONT</name>
                <description>The CONT (continuous) bit determines how the internal counter behaves when it reaches zero. If the CONT bit is 1, the counter runs continuously until it is stopped by the STOP bit. If CONT is 0, the counter stops after it reaches zero. When the counter reaches zero, it reloads with the value stored in the period registers, regardless of the CONT bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
            </field>
            <field>
                <name>START</name>
                <description>Writing a 1 to the START bit starts the internal counter running (counting down). The START bit is an event bit that enables the counter when a write operation is performed. If the timer is stopped, writing a 1 to the START bit causes the timer to restart counting from the number currently stored in its counter. If the timer is already running, writing a 1 to START has no effect. Writing 0 to the START bit has no effect.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
            </field>
            <field>
                <name>STOP</name>
                <description>Writing a 1 to the STOP bit stops the internal counter. The STOP bit is an event bit that causes the counter to stop when a write operation is performed. If the timer is already stopped, writing a 1 to STOP has no effect. Writing a 0 to the stop bit has no effect. If the timer hardware is configured with Start/Stop control bits off, writing the STOP bit has no effect.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
            </field>
            <field>
                <name>Reserved</name>
                <description>Reserved</description>
                <bitOffset>4</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
                <parameters>
                    <parameter>
                    <name>Reserved</name>
                    <value>true</value>
                    </parameter>
                </parameters>
            </field>
        </register>
        <register>
            <name>${period_name_0}</name>
            <description>The period_n registers together store the timeout period value when a write operation to one of the period_n register or the internal counter reaches 0. The timer's actual period is one cycle greater than the value stored in the period_n registers because the counter assumes the value zero for one clock cycle. Writing to one of the period_n registers stops the internal counter, except when the hardware is configured with Start/Stop control bits off. If Start/Stop control bits is off, writing either register does not stop the counter. When the hardware is configured with Writeable period disabled, writing to one of the period_n registers causes the counter to reset to the fixed Timeout Period specified at system generation time.</description>
            <addressOffset>0x2</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_name_0_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_name_1}</name>
            <description></description>
            <addressOffset>0x3</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_name_1_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_snap_0}</name>
            <description></description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_snap_0_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_snap_1}</name>
            <description></description>
            <addressOffset>0x5</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_snap_1_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_0}</name>
            <description>A master peripheral may request a coherent snapshot of the current internal counter by performing a write operation (write-data ignored) to one of the snap_n registers. When a write occurs, the value of the counter is copied to snap_n registers. The snapshot occurs whether or not the counter is running. Requesting a snapshot does not change the internal counter's operation.</description>
            <addressOffset>0x6</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_1}</name>
            <description></description>
            <addressOffset>0x7</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_2}</name>
            <description></description>
            <addressOffset>0x8</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_3}</name>
            <description></description>
            <addressOffset>0x9</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
    </registers>
   </peripheral>
  <peripheral>
      <name>nios_timer_0_s1_altera_avalon_timer</name><baseAddress>0x00000000</baseAddress> 
      <addressBlock>
        <offset>0x0</offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
       <registers>
         <register>     
          <name>status</name>  
          <displayName>Status</displayName>
          <description>The status register has two defined bits. TO (timeout), RUN</description>
          <addressOffset>0x0</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xffff</resetMask>
          <fields>
            <field><name>TO</name>
            <description>The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a timeout event, the TO bit stays set until explicitly cleared by a master peripheral. Write zero to the status register to clear the TO bit.</description>
             <bitOffset>0x0</bitOffset>
             <bitWidth>1</bitWidth>
             <access>read-only</access>
             <readAction>clear</readAction>
            </field>
            <field><name>RUN</name>
            <description>The RUN bit reads as 1 when the internal counter is running; otherwise this bit reads as 0. The RUN bit is not changed by
 a write operation to the status register.</description>
             <bitOffset>1</bitOffset>
             <bitWidth>1</bitWidth>
             <access>read-only</access>
            </field>
            <field>
             <name>Reserved</name>
             <description>Reserved</description>
             <bitOffset>2</bitOffset>
             <bitWidth>14</bitWidth>
             <access>read-write</access>
             <parameters>
                 <parameter>
                 <name>Reserved</name>
                 <value>true</value>
                 </parameter>
             </parameters>
            </field>
          </fields>
        </register> 
        <register>
            <name>control</name>
            <description>The control register has four defined bits. ITO (Timeout Interrupt), CONT (continue), START, STOP</description>
            <addressOffset>0x1</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <reset>
                <value>0x0</value>
            </reset>
            <field>
                <name>ITO</name>
                <description>If the ITO bit is 1, the interval timer core generates an IRQ when the status register's TO bit is 1. When the ITO bit is 0, the timer does not generate IRQs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
            </field>
            <field>
                <name>CONT</name>
                <description>The CONT (continuous) bit determines how the internal counter behaves when it reaches zero. If the CONT bit is 1, the counter runs continuously until it is stopped by the STOP bit. If CONT is 0, the counter stops after it reaches zero. When the counter reaches zero, it reloads with the value stored in the period registers, regardless of the CONT bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
            </field>
            <field>
                <name>START</name>
                <description>Writing a 1 to the START bit starts the internal counter running (counting down). The START bit is an event bit that enables the counter when a write operation is performed. If the timer is stopped, writing a 1 to the START bit causes the timer to restart counting from the number currently stored in its counter. If the timer is already running, writing a 1 to START has no effect. Writing 0 to the START bit has no effect.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
            </field>
            <field>
                <name>STOP</name>
                <description>Writing a 1 to the STOP bit stops the internal counter. The STOP bit is an event bit that causes the counter to stop when a write operation is performed. If the timer is already stopped, writing a 1 to STOP has no effect. Writing a 0 to the stop bit has no effect. If the timer hardware is configured with Start/Stop control bits off, writing the STOP bit has no effect.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
            </field>
            <field>
                <name>Reserved</name>
                <description>Reserved</description>
                <bitOffset>4</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
                <parameters>
                    <parameter>
                    <name>Reserved</name>
                    <value>true</value>
                    </parameter>
                </parameters>
            </field>
        </register>
        <register>
            <name>${period_name_0}</name>
            <description>The period_n registers together store the timeout period value when a write operation to one of the period_n register or the internal counter reaches 0. The timer's actual period is one cycle greater than the value stored in the period_n registers because the counter assumes the value zero for one clock cycle. Writing to one of the period_n registers stops the internal counter, except when the hardware is configured with Start/Stop control bits off. If Start/Stop control bits is off, writing either register does not stop the counter. When the hardware is configured with Writeable period disabled, writing to one of the period_n registers causes the counter to reset to the fixed Timeout Period specified at system generation time.</description>
            <addressOffset>0x2</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_name_0_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_name_1}</name>
            <description></description>
            <addressOffset>0x3</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_name_1_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_snap_0}</name>
            <description></description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_snap_0_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_snap_1}</name>
            <description></description>
            <addressOffset>0x5</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_snap_1_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_0}</name>
            <description>A master peripheral may request a coherent snapshot of the current internal counter by performing a write operation (write-data ignored) to one of the snap_n registers. When a write occurs, the value of the counter is copied to snap_n registers. The snapshot occurs whether or not the counter is running. Requesting a snapshot does not change the internal counter's operation.</description>
            <addressOffset>0x6</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_1}</name>
            <description></description>
            <addressOffset>0x7</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_2}</name>
            <description></description>
            <addressOffset>0x8</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_3}</name>
            <description></description>
            <addressOffset>0x9</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
    </registers>
   </peripheral>
  <peripheral>
      <name>nios_pio_0_s1_altera_avalon_pio</name><baseAddress>0x00000000</baseAddress> 
      <addressBlock>
        <offset>0x0</offset>
        <size>32</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>     
         <name>DATA</name>  
         <displayName>Data</displayName>
         <description>Reading from data returns the value present at the input ports. If the PIO core hardware is configured in output-only mode, reading from data returns an undefined value. Writing to data stores the value to a register that drives the output ports. If the PIO core hardware is configured in input-only mode, writing to data has no effect. If the PIO core hardware is in bidirectional mode, the registered value appears on an output port only when the corresponding bit in the direction register is set to 1 (output).</description>
         <addressOffset>0x0</addressOffset>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>data</name>
           <description>Reads: Data value currently on PIO inputs. Writes: New value to drive on PIO outputs.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
        </field>
       </fields>
     </register> 
        <register>     
         <name>DIRECTION</name>  
         <displayName>Direction</displayName>
         <description>The direction register controls the data direction for each PIO port, assuming the port is bidirectional. When bit n in direction is set to 1, port n drives out the value in the corresponding bit of the data register The direction register only exists when the PIO core hardware is configured in bidirectional mode. The mode (input, output, or bidirectional) is specified at system generation time, and cannot be changed at runtime. In input-only or output-only mode, the direction register does not exist. In this case, reading direction returns an undefined value, writing direction has no effect. After reset, all bits of direction are 0, so that all bidirectional I/O ports are configured as inputs. If those PIO ports are connected to device pins, the pins are held in a high-impedance state. In bi-directional mode, to change the direction of the PIO port, reprogram the direction register.</description>
         <addressOffset>0x4</addressOffset>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>direction</name>
            <description>Individual direction control for each I/O port. A value of 0 sets the direction to input; 1 sets the direction to output.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
        </field>
       </fields>
     </register> 
        <register>     
         <name>IRQ_MASK</name>  
         <displayName>Interrupt mask</displayName>
         <description>Setting a bit in the interruptmask register to 1 enables interrupts for the corresponding PIO input port. Interrupt behavior depends on the hardware configuration of the PIO core. The interruptmask register only exists when the hardware is configured to generate IRQs. If the core cannot generate IRQs, reading interruptmask returns an undefined value, and writing to interruptmask has no effect. After reset, all bits of interruptmask are zero, so that interrupts are disabled for all PIO ports.</description>
         <addressOffset>0x8</addressOffset>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>interruptmask</name>
            <description>IRQ enable/disable for each input port. Setting a bit to 1 enables interrupts for the corresponding port.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
        </field>
       </fields>
     </register> 
        <register>     
         <name>EDGE_CAP</name>  
         <displayName>Edge capture</displayName>
         <description>Bit n in the edgecapture register is set to 1 whenever an edge is detected on input port n. An Avalon-MM master peripheral can read the edgecapture register to determine if an edge has occurred on any of the PIO input ports. If the option Enable bit-clearing for edge capture register is turned off, writing any value to the edgecapture register clears all bits in the register. Otherwise, writing a 1 to a particular bit in the register clears only that bit. The type of edge(s) to detect is fixed in hardware at system generation time. The edgecapture register only exists when the hardware is configured to capture edges. If the core is not configured to capture edges, reading from edgecapture returns an undefined value, and writing to edgecapture has no effect.</description>
         <addressOffset>0xc</addressOffset>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>edgecapture</name>
            <description>Edge detection for each input port.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
        </field>
       </fields>
     </register> 
        <register>
         <name>SET_BIT</name>  
         <displayName>Outset</displayName>
         <description>You can use the outset register to set individual bits of the output port. For example, to set bit 6 of the output port, write 0x40 to the outset register. This register is only present when the option Enable individual bit set/clear output register is turned on.</description>
         <addressOffset>0x10</addressOffset>
         <size>32</size>
         <access>write-only</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>outset</name>
            <description>Specifies which bit of the output port to set.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>write-only</access>
        </field>
       </fields>
     </register> 
        <register>     
         <name>CLEAR_BITS</name>  
         <displayName>Outclear</displayName>
         <description>You can use the outclear register to clear individual bits of the output port. For example, writing 0x08 to the outclear register clears bit 3 of the output port. This register is only present when the option Enable individual bit set/clear output register is turned on.</description>
         <addressOffset>0x14</addressOffset>
         <size>32</size>
         <access>write-only</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>outclear</name>
            <description>Specifies which output bit to clear.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>write-only</access>
        </field>
       </fields>
     </register>            
    </registers>
   </peripheral>
  </peripherals>
</device>